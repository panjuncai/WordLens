This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
client/
  public/
    Sola.svg
    vite.svg
  src/
    assets/
      react.svg
    components/
      ArticleList.jsx
      ConfigModal.jsx
      ExerciseBoard.jsx
      HeaderBar.jsx
      HeroSection.jsx
      ImageCarousel.jsx
      LoginScreen.jsx
      ShadowingConfigModal.jsx
    constants/
      config.js
      defaults.js
    hooks/
      useArticles.js
      useAuth.js
      useAutoPlay.js
      useImageSearch.js
      useTtsAudio.js
    pages/
      DashboardPage.jsx
    services/
      articleService.js
      authService.js
      mediaService.js
      userService.js
    stores/
      useAuthStore.js
      useConfigStore.js
      useExerciseStore.js
    utils/
      textProcessor.js
    api.js
    App.css
    App.jsx
    index.css
    main.jsx
  .gitignore
  eslint.config.js
  index.html
  package.json
  README.md
  vite.config.js
doc/
  改造设计文档.md
  需求文档.md
server/
  config/
    env.js
  controllers/
    articleController.js
    authController.js
    mediaController.js
    userController.js
  db/
    index.js
  middlewares/
    authMiddleware.js
    errorHandler.js
  models/
    articleModel.js
    userModel.js
  routes/
    articleRoutes.js
    authRoutes.js
    index.js
    mediaRoutes.js
    userRoutes.js
  services/
    articleService.js
    authService.js
    imageService.js
    ttsService.js
  .env.example
  app.js
  data.db
  server.js
.gitignore
oneclick-deploy.sh
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="client/src/components/HeaderBar.jsx">
import { Button, Dropdown, Switch } from 'antd';
import { UserOutlined } from '@ant-design/icons';

export default function HeaderBar({ onOpenConfig, onLogout, themeMode, onToggleTheme }) {
  const items = [
    { key: 'config', label: 'TTS 配置' },
    {
      key: 'theme',
      label: (
        <div className="menu-switch">
          <span>暗色模式</span>
          <Switch
            size="small"
            checked={themeMode === 'dark'}
            onClick={(e) => e.stopPropagation()}
            onChange={(checked) => onToggleTheme(checked ? 'dark' : 'light')}
          />
        </div>
      ),
    },
    { type: 'divider' },
    { key: 'logout', label: '退出登录' },
  ];

  const handleMenuClick = ({ key }) => {
    if (key === 'config') {
      onOpenConfig();
    } else if (key === 'logout') {
      onLogout();
    }
  };

  return (
    <div className="topbar">
      <div className="brand">场景记单词</div>
      <Dropdown menu={{ items, onClick: handleMenuClick }} placement="bottomRight">
        <Button type="text" icon={<UserOutlined />} />
      </Dropdown>
    </div>
  );
}
</file>

<file path="client/src/constants/defaults.js">
export const SAMPLE_SCENE = `## 我的法语微电影：职场、生活与旅行

第一幕：繁忙的都市节奏
你是一名 informaticien。很 tôt，闹钟响了。你翻开 agenda，感叹 “c'est la vie”。新的一 semaine commencer，你去 société travailler。大家在 cabinet 开 réunion，一直很 tard，你只想 rentrer 回家。

第二幕：意外的转折与计划
周五 soir 终于回到家，你拿起 journal voir 广告。mais 去哪里？Londres、Vendôme tous 想去。donc，vacances 是 possible！你抱起 guitare，兴奋起来。

第三幕：旅途中的惊喜邂逅
假期开始，你做了新 coiffure，来到海边 juste là，朝 vers 沙滩 passer 一天。surprise！遇到 docteur 和 célèbre actrice，你们决定今晚 ensemble，把 reste 的故事留给明天。`;
</file>

<file path="client/src/hooks/useAuth.js">
import { useEffect, useState } from 'react';
import { message } from 'antd';
import { setAuthToken } from '../api';
import { login as loginApi, register as registerApi, me as meApi } from '../services/authService';

export default function useAuth() {
  const [token, setToken] = useState(localStorage.getItem('token') || '');
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [mode, setMode] = useState('login');
  const [initDone, setInitDone] = useState(false);

  useEffect(() => {
    if (token) {
      setAuthToken(token);
    } else {
      setAuthToken('');
    }
  }, [token]);

  useEffect(() => {
    const existing = localStorage.getItem('token');
    if (!existing) {
      setInitDone(true);
      return;
    }
    setAuthToken(existing);
    meApi()
      .then((res) => {
        setUser(res.data.user);
        setToken(existing);
      })
      .catch(() => {
        setAuthToken('');
        setToken('');
        setUser(null);
      })
      .finally(() => setInitDone(true));
  }, []);

  const handleLogin = async (email, password) => {
    setLoading(true);
    try {
      const { data } = await loginApi(email, password);
      setAuthToken(data.token);
      setToken(data.token);
      setUser(data.user);
      message.success('登录成功');
    } catch (error) {
      const detail = error.response?.data?.error || error.message;
      message.error(detail || '登录失败');
    } finally {
      setLoading(false);
    }
  };

  const handleRegister = async (email, password) => {
    setLoading(true);
    try {
      const { data } = await registerApi(email, password);
      setAuthToken(data.token);
      setToken(data.token);
      setUser(data.user);
      message.success('注册成功');
    } catch (error) {
      const detail = error.response?.data?.error || error.message;
      message.error(detail || '注册失败');
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    setAuthToken('');
    setToken('');
    setUser(null);
  };

  return {
    token,
    user,
    loading,
    mode,
    setMode,
    initDone,
    login: handleLogin,
    register: handleRegister,
    logout,
    setUser,
  };
}
</file>

<file path="client/src/hooks/useAutoPlay.js">
import { useEffect, useRef } from 'react';

export default function useAutoPlay({
  activeWordId,
  blanks,
  enabled,
  delay,
  showCloze,
  moveActive,
}) {
  const timerRef = useRef(null);

  useEffect(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
    if (!enabled || showCloze || !blanks.length) return () => {};
    const current = blanks.find((b) => b.id === activeWordId) || blanks[0];
    if (!current) return () => {};
    let cancelled = false;
    timerRef.current = setTimeout(() => {
      if (!cancelled) moveActive(1);
    }, (delay || 1) * 1000);
    return () => {
      cancelled = true;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
        timerRef.current = null;
      }
    };
  }, [activeWordId, enabled, showCloze, blanks, delay, moveActive]);

  return { timerRef };
}
</file>

<file path="client/src/services/articleService.js">
import api from '../api';

export const listArticles = () => api.get('/api/articles');
export const getArticle = (id) => api.get(`/api/articles/${id}`);
export const createArticle = (title, content) => api.post('/api/articles', { title, content });
export const updateArticle = (id, title, content) => api.put(`/api/articles/${id}`, { title, content });
export const deleteArticle = (id) => api.delete(`/api/articles/${id}`);
</file>

<file path="client/src/services/authService.js">
import api from '../api';

export const login = (email, password) => api.post('/api/auth/login', { email, password });
export const register = (email, password) => api.post('/api/auth/register', { email, password });
export const me = () => api.get('/api/auth/me');
</file>

<file path="client/src/stores/useAuthStore.js">
import { create } from 'zustand';
import { message } from 'antd';
import { setAuthToken } from '../api';
import { login as loginApi, register as registerApi, me as meApi } from '../services/authService';

const useAuthStore = create((set) => ({
  user: null,
  token: localStorage.getItem('token') || '',
  loading: false,
  mode: 'login',
  initDone: false,
  setMode: (mode) => set({ mode }),
  checkAuth: async () => {
    const existing = localStorage.getItem('token');
    if (!existing) {
      set({ initDone: true });
      return;
    }
    setAuthToken(existing);
    try {
      const { data } = await meApi();
      set({ user: data.user, token: existing, initDone: true });
    } catch {
      setAuthToken('');
      set({ user: null, token: '', initDone: true });
    }
  },
  login: async (email, password) => {
    set({ loading: true });
    try {
      const { data } = await loginApi(email, password);
      setAuthToken(data.token);
      set({ user: data.user, token: data.token });
      message.success('登录成功');
    } catch (error) {
      message.error(error.response?.data?.error || '登录失败');
    } finally {
      set({ loading: false });
    }
  },
  register: async (email, password) => {
    set({ loading: true });
    try {
      const { data } = await registerApi(email, password);
      setAuthToken(data.token);
      set({ user: data.user, token: data.token });
      message.success('注册成功');
    } catch (error) {
      message.error(error.response?.data?.error || '注册失败');
    } finally {
      set({ loading: false });
    }
  },
  logout: () => {
    setAuthToken('');
    set({ user: null, token: '' });
  },
}));

export default useAuthStore;
</file>

<file path="client/src/index.css">
* {
  margin: 0;
  padding: 0;
}

html,
body {
  min-height: 100%;
  background: #f3f6fb;
}
</file>

<file path="client/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="client/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
</file>

<file path="client/README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="doc/改造设计文档.md">
# WordLens 改造设计文档

## 目的
- 将现有“整段文本解析”改造为“句子为最小单元”的结构化存储与播放
- 支持单词/短文导入、双语展示、AI 批量解释、TTS 复用与多种学习模式
- 兼容后续多来源扩展（字幕/网页等）

## 改造范围
- 内容导入与切分
- 句子与文章的数据结构
- AI 解释与语音生成流程
- 播放与学习模式配置
- 商业化与额度策略（需求层已有，设计层提供实现落点）

## 核心概念与定义
- 文章（Article）：一段学习内容，来源类型可扩展
- 句子（Sentence）：最小语块单位，单词/短语视为句子
- 母语解释（Native Explanation）：句子的翻译或解释文本
- 语音资源（TTS Asset）：外语或母语的语音文件

## 功能流程设计
### 1) 内容导入
- 单词/短语：按换行切分为句子
- 外语文章：按句子切分为句子列表，保留段落信息
- 结果：生成文章 + 句子列表 + 排序号

### 2) 母语解释生成
- 单句生成：用户对某句触发 AI 解释
- 全文生成：对整篇文章批量生成母语解释
- 完成后以“母语 + 外语”对齐展示，可切换顺序

### 3) 语音生成与复用
- 播放前检查是否已有语音资源
- 若不存在则生成并记录语音资源
- 语速、音色作为语音复用的区分维度

### 4) 学习模式
- 全文循环 / 外语循环 / 单句循环 / 影子跟读
- 可设置母语与外语朗读次数
- 可设置句间停顿时间

## 数据结构设计（逻辑层）
### Users（现有 + 新增配置字段）
- id
- email
- password_hash
- native_language
- target_language
- ui_language
- display_order（native_first / target_first）
- playback_pause_ms
- playback_native_repeat
- playback_target_repeat
- use_ai_user_key
- use_tts_user_key
- shadowing_speeds_json
- user_tier（enum: free / vip）
- ai_limit_month
- ai_left
- ai_reset_at
- ai_ad_granted
- ai_vip_bonus
- tts_limit_month
- tts_left
- tts_reset_at
- tts_ad_granted
- tts_vip_bonus
说明：ai_left/tts_left 为当前可用额度，包含基础额度与广告/VIP 赠送；ai_ad_granted/tts_ad_granted 为本月累计发放的广告额度，用于统计与风控。
- study_total_ms
- study_today_ms
- study_today_date

### UserArticles（现有 + 新增配置字段）
- id
- user_id
- title
- content
- source_type（word_list / article / subtitle / web ）
- native_language
- target_language
- display_order（native_first / target_first）
- created_at
- updated_at

### user_article_sentences（改造后新增）
- id
- article_id
- order_index
- paragraph_index
- target_text
- native_text
- created_at
- updated_at

### UserArticleSentenceTts（改造后新增）
- id
- user_id
- sentence_id
- language_code（如 zh-CN / en-US / fr-FR）
- provider_type
- voice_id
- region
- speed
- cache_key
- url
- created_at
- updated_at
说明：cache_key 由 user_id + sentence_id + language_code + provider_type + voice_id + region + speed 生成，用于快速命中


### PublicAiProviderConfig
- id
- provider_type
- api_url
- api_key
- models（可用模型列表）
- enabled
- created_at
- updated_at
- 说明：api_url 为厂商 Base URL/Endpoint；api_key 为公共账号密钥

### PublicTtsProviderConfig
- id
- provider_type
- api_url
- api_key
- region
- enabled
- created_at
- updated_at
- 说明：api_url 为厂商 Base URL/Endpoint；api_key 为公共账号密钥

### TtsVoiceCatalog
- id
- public_tts_provider_config_id
- voice_id
- lang
- gender
- name
- created_at
- updated_at
- 说明：音色库，供公共与个人配置选择


### UserAiProvider
- id
- user_id
- public_ai_provider_config_id
- models_json（可用模型列表）
- is_default
- created_at
- updated_at
- 说明：用户可配置多个 AI 服务商；自带 key 不落库，仅在客户端保存

### UserTtsProvider
- id
- user_id
- public_tts_provider_config_id
- tts_voice_native
- tts_voice_target
- is_default
- created_at
- updated_at
- 说明：用户可配置多个 TTS 服务商；自带 key 不落库，仅在客户端保存

## 关键设计决策
- 句子唯一性：句子全局 id + 文章内排序号，保证可复用与可排序
- 段落保留：文章类保留 paragraph_index 以支持段落展示
- 语音复用维度：语速 + 音色 + 语言 + 句子

## 扩展性设计
- 新来源只需新增解析器（字幕/网页等）
- AI 厂商与 TTS 提供统一接口，便于切换

## 商业化落点
- 免费额度：每日配额 + 广告追加
- VIP：自带 key + 月度额度包
- 防薅：限频、限额、分离 AI/TTS 额度
- 公共账号策略：先采用单一公共账号 + 用户额度隔离

## 风险与应对
- 前端存储 AI key：存在泄露风险，需要后续迁移到服务端代理
- AI 成本波动：需明确额度与复用策略
- 句子切分不准确：需允许用户手动调整或二次拆分

## 交付清单
- 需求对应功能列表
- 逻辑数据模型
- 用户流程与播放规则
- 商业化策略与风控要点

## 行动计划（循序渐进）
1) 数据结构打底：调整 Users/UserArticles 字段设计，确认新增表结构与字段命名
2) 内容落库拆分：实现按句子切分写入 UserArticleSentences，并保留段落索引
3) AI 解释流程：接入 AI 配置与用户选择，支持单句/全文生成母语解释
4) TTS 缓存命中：按 cache_key 查找 UserArticleSentenceTts，未命中才生成与落库
5) 播放与学习模式：实现变速、循环、影子跟读，并读取用户偏好
6) 商业化与额度：接入月度额度与广告/ VIP 赠送逻辑，完善限频与统计
7) 迁移与兼容：处理旧数据（整段文本）到新结构的迁移策略
</file>

<file path="doc/需求文档.md">
# WordLens 需求文档

## 目标
- 帮助用户用极简流程进行外语单词与句子跟读和记忆
- 支持变速跟读与循环练习
- 支持从单词列表或短文快速导入并生成双语内容

## 核心理念
- 用户输入尽可能简单：一段外语文本即可开始学习
- 语块最小单位是“句子”，单词视为只有一个词的句子
- 学习内容以“母语 + 外语”成对展示，便于理解与跟读

## 用户角色与语言
- 用户可以设置母语与目标学习语言
- 界面默认使用母语显示，且允许用户在设置中调整

## 内容创建与导入
### 1.单词短语类
- 用户直接录入单词、短语
- 按换行切分
- 用户可一键生成母语解释，形成双语展示

### 2. 纯外语文章导入
- 用户输入纯外语文章
- 系统按句子切分
- 用户可一键生成母语解释，形成双语展示
- 句子切分需考虑真实文本中的特殊情况（如缩写、专有名词等）
- 句子切分优先采用成熟的 NLP 方案而非简单正则


### 3. 来源扩展
- 后续可扩展导入方式（如字幕、网页等）
- 扩展不改变已有使用习惯

## 句子与排序
- 每条句子都有唯一标识
- 句子保留原始顺序，便于复习与播放
- 支持在列表中按顺序浏览与播放

## 翻译与母语解释
- 外语句子可一键生成母语解释
- 生成后以“母语 + 外语”对齐展示
- 允许用户调整展示顺序（母语在前或外语在前）
- 支持对单个句子或全文进行母语解释生成
- 暂时支持火山引擎、阿里千问、OpenAI、Gemini 四大 AI 厂商
- AI 秘钥存储在客户端，用于保障安全性

## 语音播放与复用
- 支持外语与母语的语音播放
- 支持语速调节与循环播放
- 若已生成语音，可直接复用，无需重复生成
- Azure TTS 支持母语与外语音色选择，并提供试听功能

## 学习体验
- 用户可以按顺序或循环播放句子
- 支持变速跟读
- 展示内容简洁、清晰、可快速进入练习
- 支持全文循环、外语循环、单句循环与影子跟读
- 支持设置母语与外语朗读次数
- 支持设置每句之间的停顿时间

## 展示规则
- 对话类与单词类：按句子换行展示
- 文章类：保留原有段落格式展示

## 商业化策略
- 默认面向大众用户，提供每日免费额度
- 观看广告可获得额外额度
- 极客用户可开通 VIP，自带 AI/TTS key 使用
- VIP 用户同时获得系统赠送的月度额度包（如每月 TTS 字符额度）

## 防止滥用策略
- 免费额度与广告额度有每日上限与领取次数限制
- 对高频调用进行限制，避免刷量
- AI 翻译与 TTS 额度分开管理，防止互相挤占成本

## 非目标
- 当前阶段不包含复杂的学习统计或社交功能
- 当前阶段不强调多端同步与高级编辑
</file>

<file path="server/controllers/articleController.js">
const articleService = require('../services/articleService');

async function list(req, res, next) {
  try {
    const items = await articleService.list(req.user.id);
    res.json({ items });
  } catch (err) {
    next(err);
  }
}

async function get(req, res, next) {
  try {
    const article = await articleService.get(req.user.id, req.params.id);
    res.json({ article });
  } catch (err) {
    next(err);
  }
}

async function create(req, res, next) {
  try {
    const article = await articleService.create(req.user.id, req.body || {});
    res.json({ article });
  } catch (err) {
    next(err);
  }
}

async function update(req, res, next) {
  try {
    const article = await articleService.update(req.user.id, req.params.id, req.body || {});
    res.json({ article });
  } catch (err) {
    next(err);
  }
}

async function remove(req, res, next) {
  try {
    await articleService.remove(req.user.id, req.params.id);
    res.json({ ok: true });
  } catch (err) {
    next(err);
  }
}

module.exports = {
  list,
  get,
  create,
  update,
  remove,
};
</file>

<file path="server/middlewares/authMiddleware.js">
const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/env');

module.exports = (req, res, next) => {
  const header = req.headers.authorization || '';
  const [, token] = header.split(' ');
  if (!token) return res.status(401).json({ error: 'Unauthorized' });
  try {
    const payload = jwt.verify(token, jwtSecret);
    req.user = payload;
    return next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};
</file>

<file path="server/middlewares/errorHandler.js">
// eslint-disable-next-line no-unused-vars
module.exports = (err, _req, res, _next) => {
  const status = err.status || 500;
  const message = err.message || 'Internal Server Error';
  if (status >= 500) {
    console.error(err);
  }
  res.status(status).json({ error: message });
};
</file>

<file path="server/routes/articleRoutes.js">
const express = require('express');
const authMiddleware = require('../middlewares/authMiddleware');
const articleController = require('../controllers/articleController');

const router = express.Router();

router.use(authMiddleware);
router.get('/', articleController.list);
router.post('/', articleController.create);
router.get('/:id', articleController.get);
router.put('/:id', articleController.update);
router.delete('/:id', articleController.remove);

module.exports = router;
</file>

<file path="server/routes/authRoutes.js">
const express = require('express');
const authController = require('../controllers/authController');

const router = express.Router();

router.post('/register', authController.register);
router.post('/login', authController.login);
router.get('/me', require('../middlewares/authMiddleware'), authController.me);

module.exports = router;
</file>

<file path="server/routes/index.js">
const express = require('express');
const authRoutes = require('./authRoutes');
const userRoutes = require('./userRoutes');
const mediaRoutes = require('./mediaRoutes');
const articleRoutes = require('./articleRoutes');

const router = express.Router();

router.use('/auth', authRoutes);
router.use('/user', userRoutes);
router.use('/articles', articleRoutes);
router.use('/', mediaRoutes);

module.exports = router;
</file>

<file path="server/routes/mediaRoutes.js">
const express = require('express');
const mediaController = require('../controllers/mediaController');
const authMiddleware = require('../middlewares/authMiddleware');

const router = express.Router();

router.get('/images', authMiddleware, mediaController.getImages);
router.post('/tts', authMiddleware, mediaController.tts);

module.exports = router;
</file>

<file path="server/services/articleService.js">
const Joi = require('joi');
const articleModel = require('../models/articleModel');

const articleSchema = Joi.object({
  title: Joi.string().min(1).max(200).required(),
  content: Joi.string().min(1).required(),
});

async function list(userId) {
  return articleModel.listByUser(userId);
}

async function get(userId, id) {
  const article = await articleModel.findById(id, userId);
  if (!article) {
    const err = new Error('Not found');
    err.status = 404;
    throw err;
  }
  return article;
}

async function create(userId, payload) {
  const { title, content } = await articleSchema.validateAsync(payload);
  const res = await articleModel.create(userId, title, content);
  return { id: res.lastID, title, content };
}

async function update(userId, id, payload) {
  const { title, content } = await articleSchema.validateAsync(payload);
  const existing = await articleModel.findById(id, userId);
  if (!existing) {
    const err = new Error('Not found');
    err.status = 404;
    throw err;
  }
  await articleModel.update(id, userId, title, content);
  return { id, title, content };
}

async function remove(userId, id) {
  const existing = await articleModel.findById(id, userId);
  if (!existing) {
    const err = new Error('Not found');
    err.status = 404;
    throw err;
  }
  await articleModel.remove(id, userId);
  return { ok: true };
}

module.exports = {
  list,
  get,
  create,
  update,
  remove,
};
</file>

<file path="server/services/authService.js">
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const Joi = require('joi');
const userModel = require('../models/userModel');
const { jwtSecret } = require('../config/env');

const emailSchema = Joi.string().email().required();
const passwordSchema = Joi.string().min(1).required();

async function register(email, password) {
  await emailSchema.validateAsync(email);
  await passwordSchema.validateAsync(password);
  const existing = await userModel.findByEmail(email);
  if (existing) {
    const err = new Error('Email already registered');
    err.status = 409;
    throw err;
  }
  const hash = await bcrypt.hash(password, 10);
  const res = await userModel.create(email, hash);
  const user = { id: res.lastID, email };
  const token = jwt.sign(user, jwtSecret, { expiresIn: '7d' });
  return { user, token };
}

async function login(email, password) {
  await emailSchema.validateAsync(email);
  await passwordSchema.validateAsync(password);
  const user = await userModel.findByEmail(email);
  if (!user) {
    const err = new Error('Invalid credentials');
    err.status = 401;
    throw err;
  }
  const ok = await bcrypt.compare(password, user.password_hash);
  if (!ok) {
    const err = new Error('Invalid credentials');
    err.status = 401;
    throw err;
  }
  const token = jwt.sign({ id: user.id, email: user.email }, jwtSecret, { expiresIn: '7d' });
  return { user: { id: user.id, email: user.email }, token };
}

module.exports = {
  register,
  login,
};
</file>

<file path="server/services/imageService.js">
const axios = require('axios');
const cheerio = require('cheerio');

async function fetchImages(word, offset = 0) {
  const query = `${word} photo`;
  const url = `https://www.bing.com/images/search?q=${encodeURIComponent(query)}&first=${offset + 1}&count=5&cc=FR&setLang=fr`;
  const response = await axios.get(url, {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119 Safari/537.36',
      'Accept-Language': 'fr-FR,fr;q=0.9,en;q=0.8',
    },
  });
  const $ = cheerio.load(response.data);
  const urls = [];
  const seen = new Set();
  $('.iusc').each((_, el) => {
    const meta = $(el).attr('m');
    if (meta) {
      try {
        const m = JSON.parse(meta);
        if (m?.murl && /^https?:\/\//.test(m.murl) && !seen.has(m.murl)) {
          urls.push(m.murl);
          seen.add(m.murl);
        }
      } catch (err) {
        // ignore parse errors
      }
    }
    if (urls.length >= 5) return false;
    return undefined;
  });
  return urls;
}

module.exports = { fetchImages };
</file>

<file path="server/.env.example">
AZURE_SPEECH_KEY=your-key
AZURE_REGION=your-region
AZURE_VOICE=fr-FR-DeniseNeural
JWT_SECRET=replace-me
PORT=4000
</file>

<file path="server/app.js">
const express = require('express');
const cors = require('cors');
const errorHandler = require('./middlewares/errorHandler');
const routes = require('./routes');

const app = express();

app.use(cors());
app.use(express.json({ limit: '1mb' }));

app.get('/api/health', (_req, res) => res.json({ status: 'ok' }));

app.use('/api', routes);

app.use(errorHandler);

module.exports = app;
</file>

<file path="server/server.js">
const app = require('./app');
const { port } = require('./config/env');

app.listen(port, () => {
  console.log(`Server listening on http://localhost:${port}`);
});
</file>

<file path="client/public/Sola.svg">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="100%" viewBox="0 0 1199 1148" enable-background="new 0 0 1199 1148" xml:space="preserve">
<path fill="#FFFFFF" opacity="1.000000" stroke="none" 
	d="
M1200.000000,524.000000 
	C1200.000000,732.260315 1200.000000,940.520691 1200.000000,1149.000000 
	C1006.307556,1149.000000 812.614990,1149.000000 618.672607,1148.726074 
	C622.723572,1145.167969 628.293274,1142.703613 631.056213,1138.426147 
	C636.499817,1129.998901 641.527649,1120.948364 644.699829,1111.476440 
	C653.756897,1084.432983 656.401611,1056.269287 656.993774,1027.886963 
	C657.590393,999.294617 655.592896,971.039429 646.161865,943.731262 
	C642.390747,932.811646 638.206360,921.973816 629.615417,913.930542 
	C612.950439,898.327698 601.938354,901.849792 594.272034,920.044678 
	C589.852051,930.535034 586.636475,941.670349 584.112122,952.795166 
	C577.525818,981.820557 576.264771,1011.433838 576.054993,1041.071899 
	C575.875427,1066.429688 577.645752,1091.623413 585.061157,1116.081787 
	C589.045593,1129.223511 593.729675,1142.000244 607.000000,1149.000000 
	C405.070984,1149.000000 203.141983,1149.000000 1.000000,1149.000000 
	C1.000000,950.307556 1.000000,751.614990 1.325181,552.578735 
	C4.205894,558.549683 8.713781,563.393433 14.647645,566.221130 
	C24.515936,570.923645 34.461952,575.900391 44.912979,578.867554 
	C92.179474,592.287048 140.102097,592.968872 188.280594,584.421936 
	C203.468246,581.727600 218.051071,577.143494 230.772903,568.051758 
	C248.727417,555.220398 248.518494,536.272522 230.314560,523.944702 
	C217.144302,515.025818 202.189072,510.430054 186.879410,507.027496 
	C153.939713,499.706543 120.573959,498.532928 87.066101,501.286224 
	C67.094292,502.927307 47.544376,506.906708 29.015190,514.884827 
	C16.285416,520.365784 5.423233,527.885010 1.000000,542.000000 
	C1.000000,361.729736 1.000000,181.459457 1.000000,1.000000 
	C223.359131,1.000000 445.718323,1.000000 668.293091,1.258214 
	C657.010681,4.653974 650.612427,13.267056 645.976868,23.314535 
	C641.736694,32.505070 637.851685,41.901661 634.482727,51.444889 
	C617.700745,98.982262 612.607849,148.254074 613.502197,198.317963 
	C613.707458,209.809875 615.325378,221.144852 620.798157,231.635849 
	C628.795410,246.966263 651.180603,257.306122 668.928284,239.197342 
	C677.320801,230.634064 683.199097,220.473450 687.028625,209.100800 
	C705.042542,155.604294 711.451660,100.247040 713.049011,44.193275 
	C713.701538,21.297031 702.717957,6.716963 681.707825,1.650481 
	C681.435425,1.584790 681.234375,1.223374 681.000000,0.999997 
	C853.929016,1.000000 1026.858032,1.000000 1200.000000,1.000000 
	C1200.000000,171.025772 1200.000000,341.051636 1199.685303,511.304352 
	C1196.830688,490.637146 1187.873047,482.135193 1166.726074,483.185913 
	C1142.324585,484.398346 1117.916504,486.360657 1093.648926,489.181396 
	C1055.589722,493.605255 1018.155762,501.378418 982.322571,515.297729 
	C972.055664,519.285828 961.860291,524.331116 952.958679,530.735535 
	C942.279236,538.419128 941.306824,551.002747 950.620850,560.297302 
	C966.298828,575.942383 985.155823,586.430054 1008.077698,584.134521 
	C1032.681763,581.670471 1057.225464,578.090820 1081.580322,573.780945 
	C1112.184937,568.364990 1142.391724,561.099243 1171.942383,551.181519 
	C1185.929199,546.487366 1197.542114,540.193726 1200.000000,524.000000 
M584.542480,697.596741 
	C596.512634,697.089661 608.511169,696.942078 620.447144,696.001526 
	C645.990112,693.988586 669.379150,685.836975 688.861084,668.828735 
	C717.718018,643.635803 734.012695,611.343567 738.244324,573.575623 
	C741.787537,541.951233 729.698364,515.997742 704.090698,497.143341 
	C686.043518,483.855560 664.703979,481.925415 643.085815,482.667206 
	C630.372131,483.103455 618.510132,486.641846 607.972046,494.048523 
	C595.685242,502.684326 586.948975,513.456482 589.205933,529.481995 
	C590.163696,536.282715 592.806641,542.903564 595.150085,549.438904 
	C599.068665,560.366638 603.572632,571.088074 607.322266,582.069824 
	C608.090454,584.319519 607.435425,588.088562 605.905518,589.732178 
	C604.857666,590.857849 600.713867,590.291504 598.712585,589.150879 
	C583.119385,580.263123 569.023987,570.125793 561.066956,552.815552 
	C545.621460,519.214355 550.893799,489.119629 578.543945,464.755981 
	C603.244141,442.991577 632.576599,429.709198 664.025146,421.022369 
	C686.386780,414.845551 708.969543,413.795990 731.522583,420.556091 
	C759.595825,428.970825 780.249512,447.249237 797.273865,470.227081 
	C799.144592,472.751953 800.547729,476.147491 800.801392,479.250854 
	C801.666809,489.838715 802.463318,500.484406 802.308533,511.093750 
	C801.825562,544.195251 793.787903,575.618958 780.034424,605.629700 
	C761.664551,645.713989 733.787964,678.120300 699.321289,705.158875 
	C648.107605,745.335327 590.587952,765.026001 525.215149,757.031494 
	C460.819794,749.156616 417.524109,713.299744 394.278381,653.487793 
	C379.702698,615.984131 381.835846,577.432617 391.577728,539.045593 
	C406.640533,479.692200 440.515381,432.937317 488.274750,395.668854 
	C496.388458,389.337402 505.894073,384.743988 513.781250,378.176270 
	C539.993652,356.349091 551.139221,327.834625 548.757141,294.055084 
	C547.937012,282.425049 543.175903,272.380707 532.758179,266.109467 
	C523.190247,260.349731 512.583618,258.341431 501.543854,259.524231 
	C486.324097,261.154846 472.806549,267.686462 459.828735,275.270752 
	C424.947083,295.655792 394.539856,321.857300 365.130157,349.236572 
	C335.903290,376.445557 312.960358,408.339905 296.401001,444.705078 
	C280.530334,479.557800 271.566040,516.228455 267.852600,554.296509 
	C264.797424,585.617065 264.922729,616.840210 270.292542,647.884705 
	C279.519287,701.227051 303.404083,746.797119 342.546173,784.481140 
	C388.451538,828.676453 443.125214,851.999939 506.618256,854.825562 
	C539.907898,856.307007 572.834656,852.680481 605.362366,845.936584 
	C687.289307,828.950928 761.163391,795.140259 823.317322,738.329163 
	C867.390930,698.044067 892.427734,648.422424 894.211792,587.722107 
	C895.324646,549.858521 895.803894,512.091675 888.829773,474.725006 
	C886.373047,461.561920 883.838013,447.799744 877.970093,435.984131 
	C831.065491,341.538208 716.114075,307.504120 629.830994,341.665619 
	C595.091003,355.419983 565.018860,376.172729 537.658386,401.190094 
	C513.068115,423.674347 490.901398,448.199188 475.214508,477.922638 
	C461.597046,503.724945 454.972748,530.955627 459.012085,560.283813 
	C461.194672,576.130737 467.208069,590.751526 473.242950,605.352112 
	C482.404846,627.518005 492.265656,649.320923 506.139923,669.089722 
	C515.826294,682.891418 528.532593,691.857117 545.359070,694.011658 
	C558.039978,695.635437 570.826904,696.431702 584.542480,697.596741 
M822.076477,1020.412964 
	C836.325500,1035.324585 850.198914,1050.620361 864.935669,1065.033447 
	C878.055176,1077.864624 893.726624,1078.654785 908.464539,1067.881714 
	C922.779846,1057.417603 929.807739,1043.891846 920.647705,1025.065674 
	C908.066284,999.207581 896.570801,972.813477 884.924438,946.509827 
	C872.275574,917.942139 857.642212,890.573303 837.982239,866.134216 
	C829.656738,855.784729 820.041260,846.887878 807.913574,841.081177 
	C789.946960,832.478760 772.057861,836.619019 759.786011,852.362366 
	C750.077332,864.817566 750.574829,878.702881 755.154297,892.735168 
	C770.192200,938.814331 791.395630,981.708313 822.076477,1020.412964 
M1123.970703,842.329468 
	C1126.167480,835.373291 1128.969971,828.540710 1130.421631,821.432373 
	C1132.698975,810.280884 1129.730591,801.151306 1119.595215,794.200867 
	C1097.348633,778.945068 1075.464233,763.152710 1053.634277,747.300720 
	C1031.373657,731.135925 1008.666321,715.744995 983.645081,704.085022 
	C967.554138,696.586609 951.093872,690.439026 932.929565,690.838623 
	C916.380371,691.202576 905.261230,699.692200 900.210510,715.841431 
	C895.817566,729.887573 900.363098,742.227173 913.523621,751.907837 
	C914.997498,752.992004 916.512817,754.031006 918.075745,754.981140 
	C945.807129,771.839783 973.092896,789.498779 1001.414429,805.300964 
	C1030.880493,821.741760 1061.244385,836.594360 1091.424194,851.725708 
	C1106.155029,859.111389 1115.931885,856.072998 1123.970703,842.329468 
M376.386932,253.226288 
	C379.438721,254.027878 382.450104,255.071274 385.549286,255.589355 
	C399.255341,257.880585 411.863098,245.731506 409.737366,232.289490 
	C399.108490,165.078506 370.910950,105.528122 330.411560,51.448059 
	C323.134369,41.730553 314.989410,32.581135 304.341095,26.257870 
	C296.357025,21.516727 291.692749,23.315027 288.664764,31.897240 
	C272.398712,78.000313 276.553497,122.482437 299.324402,165.459076 
	C314.069244,193.287750 334.190887,216.918976 356.994659,238.345306 
	C362.734680,243.738602 369.398224,248.148972 376.386932,253.226288 
M382.392120,904.899597 
	C355.659088,938.903381 336.784393,976.978760 324.010040,1018.157776 
	C318.771637,1035.044067 314.779114,1052.189087 315.963837,1070.109131 
	C316.795532,1082.688599 323.413971,1091.818115 333.942963,1092.392090 
	C339.410156,1092.689941 345.501678,1090.846802 350.512329,1088.360840 
	C362.787170,1082.270752 372.180725,1072.378052 380.889191,1062.063232 
	C408.259979,1029.643799 427.741364,992.720215 441.589813,952.806458 
	C447.263367,936.454163 451.445374,919.595703 450.776917,902.050781 
	C450.356598,891.018616 447.560913,880.623413 436.832825,875.067261 
	C426.446564,869.688110 416.646729,873.471252 408.527405,880.070496 
	C399.411682,887.479553 391.369202,896.208984 382.392120,904.899597 
M146.604370,257.921997 
	C126.706749,251.462021 106.910812,244.657166 86.852180,238.743317 
	C80.483955,236.865784 73.423653,237.062790 66.665047,236.886826 
	C62.747314,236.784836 60.395573,239.568817 60.957386,243.506744 
	C61.769054,249.196045 61.798500,255.631561 64.601830,260.275787 
	C71.351295,271.457458 78.594254,282.612213 87.283989,292.301849 
	C115.314262,323.557312 149.758469,346.539581 186.583298,366.068359 
	C205.291214,375.989410 224.773438,384.162018 245.922714,387.332001 
	C250.805557,388.063843 255.978775,388.322998 260.826508,387.567963 
	C280.590942,384.489502 289.457703,366.177399 280.151062,347.974304 
	C272.833374,333.661469 261.139343,323.224823 248.517212,313.843079 
	C217.344650,290.673370 183.008026,273.180969 146.604370,257.921997 
M1035.440918,263.915344 
	C1041.162354,257.539978 1045.659058,250.443253 1044.640381,241.530533 
	C1041.713135,215.920380 1010.674866,201.409866 989.155212,215.402008 
	C979.112854,221.931595 969.035767,228.408875 959.045166,235.016937 
	C933.514526,251.903580 907.117981,267.631653 884.190979,288.110504 
	C874.925293,296.386841 866.117737,305.395508 858.356567,315.076904 
	C850.110229,325.363556 851.863220,335.863525 861.268188,344.906189 
	C873.019409,356.204803 886.993164,358.726379 902.421814,355.550720 
	C920.813538,351.765137 937.073059,343.092712 952.662781,333.075592 
	C982.937256,313.622803 1009.440430,289.615479 1035.440918,263.915344 
M118.637604,820.152283 
	C113.942375,826.976379 108.456017,833.400452 104.751785,840.725769 
	C100.098602,849.927551 103.404045,858.007812 112.459221,863.042419 
	C119.922455,867.192017 128.034515,867.558716 136.263153,866.527527 
	C154.520950,864.239380 171.333969,857.573547 187.421707,849.007690 
	C212.094711,835.870605 235.371704,820.750916 253.766159,799.269226 
	C260.690063,791.183289 267.319397,782.741272 270.417053,772.258606 
	C274.434479,758.663513 266.807831,747.274475 252.829285,745.848267 
	C242.660904,744.810852 232.845367,746.899231 223.501450,750.439270 
	C183.504242,765.592529 148.537949,788.465332 118.637604,820.152283 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M680.539368,0.999997 
	C681.234375,1.223374 681.435425,1.584790 681.707825,1.650481 
	C702.717957,6.716963 713.701538,21.297031 713.049011,44.193275 
	C711.451660,100.247040 705.042542,155.604294 687.028625,209.100800 
	C683.199097,220.473450 677.320801,230.634064 668.928284,239.197342 
	C651.180603,257.306122 628.795410,246.966263 620.798157,231.635849 
	C615.325378,221.144852 613.707458,209.809875 613.502197,198.317963 
	C612.607849,148.254074 617.700745,98.982262 634.482727,51.444889 
	C637.851685,41.901661 641.736694,32.505070 645.976868,23.314535 
	C650.612427,13.267056 657.010681,4.653974 668.754333,1.258214 
	C672.692932,1.000000 676.385803,1.000000 680.539368,0.999997 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M1200.000000,523.539368 
	C1197.542114,540.193726 1185.929199,546.487366 1171.942383,551.181519 
	C1142.391724,561.099243 1112.184937,568.364990 1081.580322,573.780945 
	C1057.225464,578.090820 1032.681763,581.670471 1008.077698,584.134521 
	C985.155823,586.430054 966.298828,575.942383 950.620850,560.297302 
	C941.306824,551.002747 942.279236,538.419128 952.958679,530.735535 
	C961.860291,524.331116 972.055664,519.285828 982.322571,515.297729 
	C1018.155762,501.378418 1055.589722,493.605255 1093.648926,489.181396 
	C1117.916504,486.360657 1142.324585,484.398346 1166.726074,483.185913 
	C1187.873047,482.135193 1196.830688,490.637146 1199.685303,511.765625 
	C1200.000000,515.692932 1200.000000,519.385803 1200.000000,523.539368 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M1.000000,542.454102 
	C5.423233,527.885010 16.285416,520.365784 29.015190,514.884827 
	C47.544376,506.906708 67.094292,502.927307 87.066101,501.286224 
	C120.573959,498.532928 153.939713,499.706543 186.879410,507.027496 
	C202.189072,510.430054 217.144302,515.025818 230.314560,523.944702 
	C248.518494,536.272522 248.727417,555.220398 230.772903,568.051758 
	C218.051071,577.143494 203.468246,581.727600 188.280594,584.421936 
	C140.102097,592.968872 92.179474,592.287048 44.912979,578.867554 
	C34.461952,575.900391 24.515936,570.923645 14.647645,566.221130 
	C8.713781,563.393433 4.205894,558.549683 1.325181,552.117493 
	C1.000000,548.969421 1.000000,545.938782 1.000000,542.454102 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M607.458069,1149.000000 
	C593.729675,1142.000244 589.045593,1129.223511 585.061157,1116.081787 
	C577.645752,1091.623413 575.875427,1066.429688 576.054993,1041.071899 
	C576.264771,1011.433838 577.525818,981.820557 584.112122,952.795166 
	C586.636475,941.670349 589.852051,930.535034 594.272034,920.044678 
	C601.938354,901.849792 612.950439,898.327698 629.615417,913.930542 
	C638.206360,921.973816 642.390747,932.811646 646.161865,943.731262 
	C655.592896,971.039429 657.590393,999.294617 656.993774,1027.886963 
	C656.401611,1056.269287 653.756897,1084.432983 644.699829,1111.476440 
	C641.527649,1120.948364 636.499817,1129.998901 631.056213,1138.426147 
	C628.293274,1142.703613 622.723572,1145.167969 618.211365,1148.726074 
	C614.638733,1149.000000 611.277405,1149.000000 607.458069,1149.000000 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M584.054565,697.596497 
	C570.826904,696.431702 558.039978,695.635437 545.359070,694.011658 
	C528.532593,691.857117 515.826294,682.891418 506.139923,669.089722 
	C492.265656,649.320923 482.404846,627.518005 473.242950,605.352112 
	C467.208069,590.751526 461.194672,576.130737 459.012085,560.283813 
	C454.972748,530.955627 461.597046,503.724945 475.214508,477.922638 
	C490.901398,448.199188 513.068115,423.674347 537.658386,401.190094 
	C565.018860,376.172729 595.091003,355.419983 629.830994,341.665619 
	C716.114075,307.504120 831.065491,341.538208 877.970093,435.984131 
	C883.838013,447.799744 886.373047,461.561920 888.829773,474.725006 
	C895.803894,512.091675 895.324646,549.858521 894.211792,587.722107 
	C892.427734,648.422424 867.390930,698.044067 823.317322,738.329163 
	C761.163391,795.140259 687.289307,828.950928 605.362366,845.936584 
	C572.834656,852.680481 539.907898,856.307007 506.618256,854.825562 
	C443.125214,851.999939 388.451538,828.676453 342.546173,784.481140 
	C303.404083,746.797119 279.519287,701.227051 270.292542,647.884705 
	C264.922729,616.840210 264.797424,585.617065 267.852600,554.296509 
	C271.566040,516.228455 280.530334,479.557800 296.401001,444.705078 
	C312.960358,408.339905 335.903290,376.445557 365.130157,349.236572 
	C394.539856,321.857300 424.947083,295.655792 459.828735,275.270752 
	C472.806549,267.686462 486.324097,261.154846 501.543854,259.524231 
	C512.583618,258.341431 523.190247,260.349731 532.758179,266.109467 
	C543.175903,272.380707 547.937012,282.425049 548.757141,294.055084 
	C551.139221,327.834625 539.993652,356.349091 513.781250,378.176270 
	C505.894073,384.743988 496.388458,389.337402 488.274750,395.668854 
	C440.515381,432.937317 406.640533,479.692200 391.577728,539.045593 
	C381.835846,577.432617 379.702698,615.984131 394.278381,653.487793 
	C417.524109,713.299744 460.819794,749.156616 525.215149,757.031494 
	C590.587952,765.026001 648.107605,745.335327 699.321289,705.158875 
	C733.787964,678.120300 761.664551,645.713989 780.034424,605.629700 
	C793.787903,575.618958 801.825562,544.195251 802.308533,511.093750 
	C802.463318,500.484406 801.666809,489.838715 800.801392,479.250854 
	C800.547729,476.147491 799.144592,472.751953 797.273865,470.227081 
	C780.249512,447.249237 759.595825,428.970825 731.522583,420.556091 
	C708.969543,413.795990 686.386780,414.845551 664.025146,421.022369 
	C632.576599,429.709198 603.244141,442.991577 578.543945,464.755981 
	C550.893799,489.119629 545.621460,519.214355 561.066956,552.815552 
	C569.023987,570.125793 583.119385,580.263123 598.712585,589.150879 
	C600.713867,590.291504 604.857666,590.857849 605.905518,589.732178 
	C607.435425,588.088562 608.090454,584.319519 607.322266,582.069824 
	C603.572632,571.088074 599.068665,560.366638 595.150085,549.438904 
	C592.806641,542.903564 590.163696,536.282715 589.205933,529.481995 
	C586.948975,513.456482 595.685242,502.684326 607.972046,494.048523 
	C618.510132,486.641846 630.372131,483.103455 643.085815,482.667206 
	C664.703979,481.925415 686.043518,483.855560 704.090698,497.143341 
	C729.698364,515.997742 741.787537,541.951233 738.244324,573.575623 
	C734.012695,611.343567 717.718018,643.635803 688.861084,668.828735 
	C669.379150,685.836975 645.990112,693.988586 620.447144,696.001526 
	C608.511169,696.942078 596.512634,697.089661 584.054565,697.596497 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M821.863159,1020.129883 
	C791.395630,981.708313 770.192200,938.814331 755.154297,892.735168 
	C750.574829,878.702881 750.077332,864.817566 759.786011,852.362366 
	C772.057861,836.619019 789.946960,832.478760 807.913574,841.081177 
	C820.041260,846.887878 829.656738,855.784729 837.982239,866.134216 
	C857.642212,890.573303 872.275574,917.942139 884.924438,946.509827 
	C896.570801,972.813477 908.066284,999.207581 920.647705,1025.065674 
	C929.807739,1043.891846 922.779846,1057.417603 908.464539,1067.881714 
	C893.726624,1078.654785 878.055176,1077.864624 864.935669,1065.033447 
	C850.198914,1050.620361 836.325500,1035.324585 821.863159,1020.129883 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M1123.811279,842.666992 
	C1115.931885,856.072998 1106.155029,859.111389 1091.424194,851.725708 
	C1061.244385,836.594360 1030.880493,821.741760 1001.414429,805.300964 
	C973.092896,789.498779 945.807129,771.839783 918.075745,754.981140 
	C916.512817,754.031006 914.997498,752.992004 913.523621,751.907837 
	C900.363098,742.227173 895.817566,729.887573 900.210510,715.841431 
	C905.261230,699.692200 916.380371,691.202576 932.929565,690.838623 
	C951.093872,690.439026 967.554138,696.586609 983.645081,704.085022 
	C1008.666321,715.744995 1031.373657,731.135925 1053.634277,747.300720 
	C1075.464233,763.152710 1097.348633,778.945068 1119.595215,794.200867 
	C1129.730591,801.151306 1132.698975,810.280884 1130.421631,821.432373 
	C1128.969971,828.540710 1126.167480,835.373291 1123.811279,842.666992 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M376.012146,253.118683 
	C369.398224,248.148972 362.734680,243.738602 356.994659,238.345306 
	C334.190887,216.918976 314.069244,193.287750 299.324402,165.459076 
	C276.553497,122.482437 272.398712,78.000313 288.664764,31.897240 
	C291.692749,23.315027 296.357025,21.516727 304.341095,26.257870 
	C314.989410,32.581135 323.134369,41.730553 330.411560,51.448059 
	C370.910950,105.528122 399.108490,165.078506 409.737366,232.289490 
	C411.863098,245.731506 399.255341,257.880585 385.549286,255.589355 
	C382.450104,255.071274 379.438721,254.027878 376.012146,253.118683 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M382.625977,904.631775 
	C391.369202,896.208984 399.411682,887.479553 408.527405,880.070496 
	C416.646729,873.471252 426.446564,869.688110 436.832825,875.067261 
	C447.560913,880.623413 450.356598,891.018616 450.776917,902.050781 
	C451.445374,919.595703 447.263367,936.454163 441.589813,952.806458 
	C427.741364,992.720215 408.259979,1029.643799 380.889191,1062.063232 
	C372.180725,1072.378052 362.787170,1082.270752 350.512329,1088.360840 
	C345.501678,1090.846802 339.410156,1092.689941 333.942963,1092.392090 
	C323.413971,1091.818115 316.795532,1082.688599 315.963837,1070.109131 
	C314.779114,1052.189087 318.771637,1035.044067 324.010040,1018.157776 
	C336.784393,976.978760 355.659088,938.903381 382.625977,904.631775 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M146.972443,258.030457 
	C183.008026,273.180969 217.344650,290.673370 248.517212,313.843079 
	C261.139343,323.224823 272.833374,333.661469 280.151062,347.974304 
	C289.457703,366.177399 280.590942,384.489502 260.826508,387.567963 
	C255.978775,388.322998 250.805557,388.063843 245.922714,387.332001 
	C224.773438,384.162018 205.291214,375.989410 186.583298,366.068359 
	C149.758469,346.539581 115.314262,323.557312 87.283989,292.301849 
	C78.594254,282.612213 71.351295,271.457458 64.601830,260.275787 
	C61.798500,255.631561 61.769054,249.196045 60.957386,243.506744 
	C60.395573,239.568817 62.747314,236.784836 66.665047,236.886826 
	C73.423653,237.062790 80.483955,236.865784 86.852180,238.743317 
	C106.910812,244.657166 126.706749,251.462021 146.972443,258.030457 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M1035.188965,264.166809 
	C1009.440430,289.615479 982.937256,313.622803 952.662781,333.075592 
	C937.073059,343.092712 920.813538,351.765137 902.421814,355.550720 
	C886.993164,358.726379 873.019409,356.204803 861.268188,344.906189 
	C851.863220,335.863525 850.110229,325.363556 858.356567,315.076904 
	C866.117737,305.395508 874.925293,296.386841 884.190979,288.110504 
	C907.117981,267.631653 933.514526,251.903580 959.045166,235.016937 
	C969.035767,228.408875 979.112854,221.931595 989.155212,215.402008 
	C1010.674866,201.409866 1041.713135,215.920380 1044.640381,241.530533 
	C1045.659058,250.443253 1041.162354,257.539978 1035.188965,264.166809 
z"/>
<path fill="#FFD204" opacity="1.000000" stroke="none" 
	d="
M118.860268,819.874756 
	C148.537949,788.465332 183.504242,765.592529 223.501450,750.439270 
	C232.845367,746.899231 242.660904,744.810852 252.829285,745.848267 
	C266.807831,747.274475 274.434479,758.663513 270.417053,772.258606 
	C267.319397,782.741272 260.690063,791.183289 253.766159,799.269226 
	C235.371704,820.750916 212.094711,835.870605 187.421707,849.007690 
	C171.333969,857.573547 154.520950,864.239380 136.263153,866.527527 
	C128.034515,867.558716 119.922455,867.192017 112.459221,863.042419 
	C103.404045,858.007812 100.098602,849.927551 104.751785,840.725769 
	C108.456017,833.400452 113.942375,826.976379 118.860268,819.874756 
z"/>
</svg>
</file>

<file path="client/src/components/LoginScreen.jsx">
import { Button, Card, Input, Space, Typography } from 'antd';
import { useEffect, useMemo, useRef, useState } from 'react';

const { Text } = Typography;

export default function LoginScreen({
  mode,
  setMode,
  email,
  password,
  onChangeEmail,
  onChangePassword,
  onSubmit,
  loading,
}) {
  const messages = useMemo(() => [
    '想场景化背单词吗？',
    '想体验AI加速背单词快感吗？',
    '还不快来试试！',
    '请把想背单词场景化并粘贴到下面',
    '进入文章后可以用Tab、上下左右键快速点读',
  ], []);
  const [typed, setTyped] = useState('');
  const introStateRef = useRef({ line: 0, char: 0 });

  useEffect(() => {
    let timer = null;
    const typeNext = () => {
      const { line, char } = introStateRef.current;
      const current = messages[line];
      if (!current) return;
      if (char < current.length) {
        setTyped(current.slice(0, char + 1));
        introStateRef.current = { line, char: char + 1 };
        timer = setTimeout(typeNext, 70);
      } else if (line < messages.length - 1) {
        timer = setTimeout(() => {
          introStateRef.current = { line: line + 1, char: 0 };
          setTyped('');
          typeNext();
        }, 900);
      } else {
        setTyped(current);
        introStateRef.current = { line, char: current.length };
      }
    };
    typeNext();
    return () => {
      if (timer) clearTimeout(timer);
    };
  }, [messages]);

  return (
    <div className="auth-wrap">
      <Card className="auth-card">
        <div className="auth-typing typing-text">{typed || '\u00a0'}</div>
        <div className="auth-header">
          <Text strong>{mode === 'login' ? '登录' : '注册'}</Text>
          <Button type="link" onClick={() => setMode(mode === 'login' ? 'register' : 'login')}>
            {mode === 'login' ? '去注册' : '去登录'}
          </Button>
        </div>
        <Space direction="vertical" style={{ width: '100%' }}>
          <Input placeholder="邮箱" value={email} onChange={(e) => onChangeEmail(e.target.value)} />
          <Input.Password placeholder="密码" value={password} onChange={(e) => onChangePassword(e.target.value)} />
          <Button type="primary" block loading={loading} onClick={onSubmit}>
            {mode === 'login' ? '登录' : '注册'}
          </Button>
        </Space>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/components/ShadowingConfigModal.jsx">
import { Button, InputNumber, Modal, Space, Switch, Typography } from 'antd';
import { MinusOutlined, PlusOutlined } from '@ant-design/icons';

export default function ShadowingConfigModal({
  open,
  onClose,
  shadowingEnabled,
  setShadowingEnabled,
  shadowingSequence,
  setShadowingSequence,
}) {
  const updateSequence = (next) => {
    setShadowingSequence(next.filter((v) => typeof v === 'number' && Number.isFinite(v)));
  };

  const handleChangeItem = (idx, val) => {
    const next = [...shadowingSequence];
    next[idx] = Number(val);
    updateSequence(next);
  };

  const handleAdd = () => {
    updateSequence([...shadowingSequence, 1.0]);
  };

  const handleRemove = (idx) => {
    const next = shadowingSequence.filter((_, i) => i !== idx);
    updateSequence(next);
  };

  return (
    <Modal
      open={open}
      title="影子跟读配置"
      onCancel={onClose}
      onOk={onClose}
    >
      <Space direction="vertical" style={{ width: '100%' }}>
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 12 }}>
          <Typography.Text>影子跟读</Typography.Text>
          <Switch checked={shadowingEnabled} onChange={setShadowingEnabled} />
        </div>
        <div>
          <Typography.Text type="secondary">速率序列</Typography.Text>
          <Space direction="vertical" style={{ width: '100%', marginTop: 8 }}>
            {shadowingSequence.map((val, idx) => (
              <div key={`rate-${idx}`} style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <InputNumber
                  min={0.1}
                  max={3}
                  step={0.1}
                  value={val}
                  onChange={(v) => handleChangeItem(idx, v)}
                  style={{ width: 120 }}
                />
                <Button
                  icon={<MinusOutlined />}
                  onClick={() => handleRemove(idx)}
                  disabled={shadowingSequence.length <= 1}
                />
              </div>
            ))}
            <Button icon={<PlusOutlined />} onClick={handleAdd}>
              添加速率
            </Button>
          </Space>
        </div>
      </Space>
    </Modal>
  );
}
</file>

<file path="client/src/hooks/useImageSearch.js">
import { useState, useCallback } from 'react';
import { message } from 'antd';
import { fetchImages } from '../services/mediaService';
import { IMAGE_PREFETCH_CONCURRENCY } from '../constants/config';

export default function useImageSearch() {
  const [imageMap, setImageMap] = useState({});
  const [prefetching, setPrefetching] = useState(false);
  const [prefetchProgress, setPrefetchProgress] = useState({ done: 0, total: 0 });

  const preloadImages = (urls = []) => Promise.all(
    urls.map(
      (src) => new Promise((resolve) => {
        const img = new Image();
        img.onload = img.onerror = resolve;
        img.src = src;
      }),
    ),
  );

  const loadImages = useCallback(async (word, refresh = false) => {
    const key = word.toLowerCase();
    let current = {};
    setImageMap((prev) => {
      current = prev[key] || {};
      const nextPage = refresh ? (current.page || 0) + 1 : current.page || 0;
      if (current.loading) return prev;
      if (!refresh && current.urls) return prev;
      return {
        ...prev,
        [key]: { ...current, loading: true, error: null, page: nextPage },
      };
    });
    const nextPage = refresh ? (current.page || 0) + 1 : current.page || 0;
    if (current.loading || (!refresh && current.urls)) return current.urls;
    try {
      const { data } = await fetchImages(word, nextPage * 5);
      const urls = data?.urls || [];
      setImageMap((prev) => ({
        ...prev,
        [key]: { urls, loading: false, error: null, page: nextPage },
      }));
      preloadImages(urls);
      return urls;
    } catch (error) {
      setImageMap((prev) => ({
        ...prev,
        [key]: {
          urls: prev[key]?.urls || current.urls || [],
          loading: false,
          error: '获取图片失败',
          page: current.page || 0,
        },
      }));
      throw error;
    }
  }, []);

  const prefetchImages = async (words) => {
    if (!words.length) {
      message.info('暂无可缓存的图片词汇');
      return;
    }
    setPrefetching(true);
    setPrefetchProgress({ done: 0, total: words.length });
    try {
      let done = 0;
      for (let i = 0; i < words.length; i += IMAGE_PREFETCH_CONCURRENCY) {
        const chunk = words.slice(i, i + IMAGE_PREFETCH_CONCURRENCY);
        await Promise.all(chunk.map((w) => loadImages(w).catch(() => {})));
        done += chunk.length;
        setPrefetchProgress({ done: Math.min(done, words.length), total: words.length });
      }
      message.success('图片缓存完成');
    } catch {
      message.error('图片缓存失败');
    } finally {
      setPrefetching(false);
    }
  };

  return {
    imageMap,
    loadImages,
    prefetchImages,
    prefetching,
    prefetchProgress,
  };
}
</file>

<file path="client/src/services/userService.js">
import api from '../api';

export const getConfig = () => api.get('/api/user/config');
export const saveConfig = (payload) => api.put('/api/user/config', payload);

export const getStudyStats = (tzOffsetMinutes) => api.get('/api/user/stats', {
  params: { tz_offset_minutes: tzOffsetMinutes },
});

export const addStudyTime = (deltaMs, tzOffsetMinutes) => api.post('/api/user/stats/time', {
  delta_ms: deltaMs,
  tz_offset_minutes: tzOffsetMinutes,
});
</file>

<file path="client/src/api.js">
import axios from 'axios';

const baseURL = '/';

const api = axios.create({
  baseURL: baseURL,
});

export const setAuthToken = (token) => {
  if (token) {
    api.defaults.headers.common.Authorization = `Bearer ${token}`;
    localStorage.setItem('token', token);
  } else {
    delete api.defaults.headers.common.Authorization;
    localStorage.removeItem('token');
  }
};

export default api;
</file>

<file path="client/src/App.jsx">
import { useEffect, useState } from 'react';
import { ConfigProvider, theme } from 'antd';
import LoginScreen from './components/LoginScreen';
import DashboardPage from './pages/DashboardPage';
import useAuthStore from './stores/useAuthStore';
import useConfigStore from './stores/useConfigStore';
import './App.css';

function App() {
  const {
    user,
    mode: authMode,
    setMode: setAuthMode,
    loading: authLoading,
    login,
    register,
    checkAuth,
    initDone,
  } = useAuthStore();
  const { themeMode } = useConfigStore();
  const [authEmail, setAuthEmail] = useState('');
  const [authPassword, setAuthPassword] = useState('');

  useEffect(() => {
    checkAuth();
  }, [checkAuth]);

  useEffect(() => {
    document.body.setAttribute('data-theme', themeMode);
  }, [themeMode]);

  const handleAuthSubmit = async () => {
    if (authMode === 'login') await login(authEmail, authPassword);
    else await register(authEmail, authPassword);
  };

  if (!initDone) return null;

  if (!user) {
    return (
      <LoginScreen
        mode={authMode}
        setMode={setAuthMode}
        email={authEmail}
        password={authPassword}
        onChangeEmail={setAuthEmail}
        onChangePassword={setAuthPassword}
        onSubmit={handleAuthSubmit}
        loading={authLoading}
      />
    );
  }

  return (
    <ConfigProvider
      theme={{
        algorithm: themeMode === 'dark' ? theme.darkAlgorithm : theme.defaultAlgorithm,
        token: { colorPrimary: '#2563eb' },
      }}
    >
      <DashboardPage />
    </ConfigProvider>
  );
}

export default App;
</file>

<file path="client/src/main.jsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { registerSW } from 'virtual:pwa-register';
import 'antd/dist/reset.css';
import './index.css';
import App from './App.jsx';

if (typeof window !== 'undefined') {
  registerSW({ immediate: true });
}

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="client/package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@ant-design/icons": "^6.1.0",
    "antd": "^6.0.1",
    "axios": "^1.13.2",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-markdown": "^10.1.0",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "^7.2.4",
    "vite-plugin-pwa": "^1.2.0"
  }
}
</file>

<file path="server/config/env.js">
const dotenv = require('dotenv');
const path = require('path');

dotenv.config({ path: path.join(__dirname, '..', '.env') });
dotenv.config();

const requiredVars = ['JWT_SECRET'];
const missing = requiredVars.filter((key) => !process.env[key]);
if (missing.length) {
  throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
}

module.exports = {
  port: process.env.PORT || 5001,
  defaultVoice: process.env.AZURE_VOICE || 'fr-FR-DeniseNeural',
  jwtSecret: process.env.JWT_SECRET,
  azureKey: process.env.AZURE_SPEECH_KEY,
  azureRegion: process.env.AZURE_REGION,
};
</file>

<file path="server/controllers/authController.js">
const authService = require('../services/authService');
const userModel = require('../models/userModel');

async function register(req, res, next) {
  const { email, password } = req.body || {};
  try {
    const data = await authService.register(email, password);
    res.json(data);
  } catch (err) {
    next(err);
  }
}

async function login(req, res, next) {
  const { email, password } = req.body || {};
  console.log('👉 收到登录请求！Body:', req.body);
  try {
    const data = await authService.login(email, password);
    res.json(data);
  } catch (err) {
    next(err);
  }
}

async function me(req, res, next) {
  try {
    const user = await userModel.findById(req.user.id);
    res.json({ user: { id: user.id, email: user.email } });
  } catch (err) {
    next(err);
  }
}

module.exports = {
  register,
  login,
  me,
};
</file>

<file path="server/controllers/userController.js">
const userModel = require('../models/userModel');

const getLocalDay = (tzOffsetMinutes) => {
  const offset = Number.isFinite(tzOffsetMinutes) ? tzOffsetMinutes : new Date().getTimezoneOffset();
  const local = new Date(Date.now() - offset * 60 * 1000);
  return local.toISOString().slice(0, 10);
};

async function getConfig(req, res, next) {
  try {
    const user = await userModel.findById(req.user.id);
    res.json({
      azure_key: user?.azure_key || '',
      azure_region: user?.azure_region || '',
      azure_voice: user?.azure_voice || '',
    });
  } catch (err) {
    next(err);
  }
}

async function getStudyStats(req, res, next) {
  try {
    const tzOffsetMinutes = Number(req.query?.tz_offset_minutes);
    const today = getLocalDay(Number.isFinite(tzOffsetMinutes) ? tzOffsetMinutes : undefined);
    const user = await userModel.findById(req.user.id);
    const totalMs = Number(user?.study_total_ms) || 0;
    const storedDay = user?.study_today_date || null;
    let todayMs = Number(user?.study_today_ms) || 0;
    if (storedDay !== today) {
      todayMs = 0;
      await userModel.updateStudyStats(req.user.id, {
        studyTotalMs: totalMs,
        studyTodayMs: 0,
        studyTodayDate: today,
      });
    }
    res.json({ today_ms: todayMs, total_ms: totalMs, day: today });
  } catch (err) {
    next(err);
  }
}

async function addStudyTime(req, res, next) {
  try {
    const { delta_ms: deltaMsRaw, tz_offset_minutes: tzOffsetMinutesRaw } = req.body || {};
    const deltaMs = Number(deltaMsRaw);
    const tzOffsetMinutes = Number(tzOffsetMinutesRaw);
    if (!Number.isFinite(deltaMs) || deltaMs <= 0) {
      res.status(400).json({ error: 'delta_ms 必须为正数' });
      return;
    }
    // Client should send small increments; cap to reduce abuse and accidental huge deltas.
    const safeDelta = Math.min(deltaMs, 5 * 60 * 1000);
    const today = getLocalDay(Number.isFinite(tzOffsetMinutes) ? tzOffsetMinutes : undefined);
    const user = await userModel.findById(req.user.id);
    const totalMs = (Number(user?.study_total_ms) || 0) + safeDelta;
    const storedDay = user?.study_today_date || null;
    const baseTodayMs = storedDay === today ? (Number(user?.study_today_ms) || 0) : 0;
    const todayMs = baseTodayMs + safeDelta;
    await userModel.updateStudyStats(req.user.id, {
      studyTotalMs: totalMs,
      studyTodayMs: todayMs,
      studyTodayDate: today,
    });
    res.json({ today_ms: todayMs, total_ms: totalMs, day: today });
  } catch (err) {
    next(err);
  }
}

async function updateConfig(req, res, next) {
  const { azure_key: azureKey, azure_region: azureRegion, azure_voice: azureVoice } = req.body || {};
  try {
    await userModel.updateConfig(req.user.id, { azureKey, azureRegion, azureVoice });
    res.json({ ok: true });
  } catch (err) {
    next(err);
  }
}

module.exports = { getConfig, updateConfig, getStudyStats, addStudyTime };
</file>

<file path="server/db/index.js">
const path = require('path');
const sqlite3 = require('sqlite3').verbose();

const db = new sqlite3.Database(path.join(__dirname, '..', 'data.db'));

db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    azure_key TEXT,
    azure_region TEXT,
    azure_voice TEXT,
    study_total_ms INTEGER DEFAULT 0,
    study_today_ms INTEGER DEFAULT 0,
    study_today_date TEXT
  )`);
  db.run('ALTER TABLE users ADD COLUMN azure_key TEXT', () => {});
  db.run('ALTER TABLE users ADD COLUMN azure_region TEXT', () => {});
  db.run('ALTER TABLE users ADD COLUMN azure_voice TEXT', () => {});
  db.run('ALTER TABLE users ADD COLUMN study_total_ms INTEGER DEFAULT 0', () => {});
  db.run('ALTER TABLE users ADD COLUMN study_today_ms INTEGER DEFAULT 0', () => {});
  db.run('ALTER TABLE users ADD COLUMN study_today_date TEXT', () => {});
  db.run(`CREATE TABLE IF NOT EXISTS user_articles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user_id) REFERENCES users(id)
  )`);
});

const run = (sql, params = []) => new Promise((resolve, reject) => {
  db.run(sql, params, function cb(err) {
    if (err) reject(err);
    else resolve(this);
  });
});

const get = (sql, params = []) => new Promise((resolve, reject) => {
  db.get(sql, params, (err, row) => {
    if (err) reject(err);
    else resolve(row);
  });
});

module.exports = {
  db,
  run,
  get,
};
</file>

<file path="server/models/articleModel.js">
const { get, run, db } = require('../db');

const listByUser = (userId) => new Promise((resolve, reject) => {
  db.all(
    'SELECT id, title, updated_at FROM user_articles WHERE user_id = ? ORDER BY updated_at DESC',
    [userId],
    (err, rows) => {
      if (err) reject(err);
      else resolve(rows);
    },
  );
});

const findById = (id, userId) => get('SELECT * FROM user_articles WHERE id = ? AND user_id = ?', [id, userId]);

const create = (userId, title, content) => run(
  'INSERT INTO user_articles (user_id, title, content) VALUES (?, ?, ?)',
  [userId, title, content],
);

const update = (id, userId, title, content) => run(
  'UPDATE user_articles SET title = ?, content = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ? AND user_id = ?',
  [title, content, id, userId],
);

const remove = (id, userId) => run('DELETE FROM user_articles WHERE id = ? AND user_id = ?', [id, userId]);

module.exports = {
  listByUser,
  findById,
  create,
  update,
  remove,
};
</file>

<file path="server/models/userModel.js">
const { get, run } = require('../db');

const findByEmail = (email) => get('SELECT * FROM users WHERE email = ?', [email]);
const findById = (id) => get('SELECT * FROM users WHERE id = ?', [id]);
const create = (email, passwordHash) => run('INSERT INTO users (email, password_hash) VALUES (?, ?)', [email, passwordHash]);
const updateConfig = (id, { azureKey, azureRegion, azureVoice }) => run(
  'UPDATE users SET azure_key = ?, azure_region = ?, azure_voice = ? WHERE id = ?',
  [azureKey || '', azureRegion || '', azureVoice || '', id],
);

const updateStudyStats = (id, { studyTotalMs, studyTodayMs, studyTodayDate }) => run(
  'UPDATE users SET study_total_ms = ?, study_today_ms = ?, study_today_date = ? WHERE id = ?',
  [studyTotalMs || 0, studyTodayMs || 0, studyTodayDate || null, id],
);

module.exports = {
  findByEmail,
  findById,
  create,
  updateConfig,
  updateStudyStats,
};
</file>

<file path="server/routes/userRoutes.js">
const express = require('express');
const userController = require('../controllers/userController');
const authMiddleware = require('../middlewares/authMiddleware');

const router = express.Router();

router.get('/config', authMiddleware, userController.getConfig);
router.put('/config', authMiddleware, userController.updateConfig);
router.get('/stats', authMiddleware, userController.getStudyStats);
router.post('/stats/time', authMiddleware, userController.addStudyTime);

module.exports = router;
</file>

<file path="server/services/ttsService.js">
const axios = require('axios');
const { defaultVoice, azureKey: envKey, azureRegion: envRegion } = require('../config/env');

async function synthesize(text, { voice, azureKey, azureRegion, rate = 1.0 }) {
  const key = azureKey || envKey;
  const region = azureRegion || envRegion;
  const voiceName = voice || defaultVoice;
  if (!key || !region) {
    const err = new Error('Missing AZURE_SPEECH_KEY or AZURE_REGION env vars');
    err.status = 500;
    throw err;
  }
  const ssml = `<speak version="1.0" xml:lang="fr-FR"><voice name="${voiceName}"><prosody rate="${rate}">${text}</prosody></voice></speak>`;
  const ttsResponse = await axios.post(
    `https://${region}.tts.speech.microsoft.com/cognitiveservices/v1`,
    ssml,
    {
      headers: {
        'Ocp-Apim-Subscription-Key': key,
        'Ocp-Apim-Subscription-Region': region,
        'Content-Type': 'application/ssml+xml',
        'X-Microsoft-OutputFormat': 'audio-24khz-48kbitrate-mono-mp3',
      },
      responseType: 'arraybuffer',
      proxy: false,
    },
  );
  return {
    audioBase64: Buffer.from(ttsResponse.data).toString('base64'),
    format: 'audio/mp3',
  };
}

module.exports = { synthesize };
</file>

<file path="oneclick-deploy.sh">
#!/bin/bash

set -euo pipefail

SERVER_IP="${SERVER_IP:-101.133.149.17}"
USERNAME="${USERNAME:-root}"
DEPLOY_ROOT="${DEPLOY_ROOT:-/opt/wordlens}"
BACKUP_ROOT="${BACKUP_ROOT:-/opt/wordlens-backups}"
FRONT_REMOTE_DIR="$DEPLOY_ROOT/frontend"
BACK_REMOTE_DIR="$DEPLOY_ROOT/backend"
PM2_APP_NAME="${PM2_APP_NAME:-wordlens}"

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FRONT_ARCHIVE="wordlens-frontend_$(date +%Y%m%d_%H%M%S).tar.gz"
BACK_ARCHIVE="wordlens-backend_$(date +%Y%m%d_%H%M%S).tar.gz"

cleanup() {
  rm -f "$PROJECT_ROOT/$FRONT_ARCHIVE" "$PROJECT_ROOT/$BACK_ARCHIVE"
}
trap cleanup EXIT

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "缺少依赖: $1"
    exit 1
  fi
}

require_cmd npm
require_cmd tar
require_cmd ssh
require_cmd scp

if [ ! -d "$PROJECT_ROOT/client" ] || [ ! -d "$PROJECT_ROOT/server" ]; then
  echo "请在项目根目录运行该脚本"
  exit 1
fi

echo "=== 构建前端 ==="
pushd "$PROJECT_ROOT/client" >/dev/null
if [ ! -d node_modules ]; then
  echo "安装前端依赖..."
  npm install
fi
echo "执行 Vite 构建..."
npm run build
popd >/dev/null

echo "打包前端构建产物: $FRONT_ARCHIVE"
tar -czf "$PROJECT_ROOT/$FRONT_ARCHIVE" -C "$PROJECT_ROOT/client/dist" .

echo "=== 准备后端 ==="
if [ ! -f "$PROJECT_ROOT/package.json" ] || [ ! -d "$PROJECT_ROOT/server" ]; then
  echo "后端目录结构缺失"
  exit 1
fi

echo "打包后端代码: $BACK_ARCHIVE"
tar -czf "$PROJECT_ROOT/$BACK_ARCHIVE" \
  --exclude='server/data.db' \
  --exclude='server/.env' \
  -C "$PROJECT_ROOT" \
  package.json \
  package-lock.json \
  server

FRONT_ARCHIVE_NAME="$(basename "$FRONT_ARCHIVE")"
BACK_ARCHIVE_NAME="$(basename "$BACK_ARCHIVE")"

echo "=== 上传构建产物到服务器 $SERVER_IP ==="
scp "$PROJECT_ROOT/$FRONT_ARCHIVE_NAME" "$USERNAME@$SERVER_IP:/tmp/"
scp "$PROJECT_ROOT/$BACK_ARCHIVE_NAME" "$USERNAME@$SERVER_IP:/tmp/"

echo "=== 远程部署 ==="
ssh "$USERNAME@$SERVER_IP" bash -s <<EOF
set -euo pipefail

DEPLOY_ROOT="$DEPLOY_ROOT"
BACKUP_ROOT="$BACKUP_ROOT"
FRONT_REMOTE_DIR="$FRONT_REMOTE_DIR"
FRONT_ARCHIVE_NAME="$FRONT_ARCHIVE_NAME"

BACK_REMOTE_DIR="$BACK_REMOTE_DIR"
BACK_ARCHIVE_NAME="$BACK_ARCHIVE_NAME"
PM2_APP_NAME="$PM2_APP_NAME"

DEPLOY_TS=\$(date +%Y%m%d_%H%M%S)

mkdir -p "\$DEPLOY_ROOT" "\$BACKUP_ROOT"
if [ -d "\$DEPLOY_ROOT" ]; then
  cp -r "\$DEPLOY_ROOT" "\$BACKUP_ROOT/wordlens_\$DEPLOY_TS"
fi

echo "--- 前端部署 ---"
rm -rf "\$FRONT_REMOTE_DIR"
mkdir -p "\$FRONT_REMOTE_DIR"
tar -xzf "/tmp/\$FRONT_ARCHIVE_NAME" -C "\$FRONT_REMOTE_DIR"
rm -f "/tmp/\$FRONT_ARCHIVE_NAME"
systemctl restart nginx

echo "--- 后端部署 ---"
if pm2 describe "\$PM2_APP_NAME" >/dev/null 2>&1; then
  pm2 stop "\$PM2_APP_NAME"
  pm2 delete "\$PM2_APP_NAME"
fi

DATA_TMP="/tmp/wordlens_data_\$DEPLOY_TS.db"
ENV_TMP="/tmp/wordlens_env_\$DEPLOY_TS"
if [ -f "\$BACK_REMOTE_DIR/server/data.db" ]; then
  mv "\$BACK_REMOTE_DIR/server/data.db" "\$DATA_TMP"
fi
if [ -f "\$BACK_REMOTE_DIR/server/.env" ]; then
  mv "\$BACK_REMOTE_DIR/server/.env" "\$ENV_TMP"
fi

rm -rf "\$BACK_REMOTE_DIR"
mkdir -p "\$BACK_REMOTE_DIR"
tar -xzf "/tmp/\$BACK_ARCHIVE_NAME" -C "\$BACK_REMOTE_DIR"
rm -f "/tmp/\$BACK_ARCHIVE_NAME"

cd "\$BACK_REMOTE_DIR"
npm ci --only=production
if [ -f "\$ENV_TMP" ]; then
  mv "\$ENV_TMP" server/.env
elif [ -f server/.env.example ]; then
  cp server/.env.example server/.env
fi
if [ -f "\$DATA_TMP" ]; then
  mv "\$DATA_TMP" server/data.db
fi
pm2 start npm --name "\$PM2_APP_NAME" -- start
pm2 save
pm2 startup

echo "=== 部署完成 ==="
pm2 status
EOF

echo "=== 部署完成 ==="
echo "部署根目录: $DEPLOY_ROOT"
echo "备份目录: $BACKUP_ROOT"
</file>

<file path="package.json">
{
  "name": "wordlens",
  "version": "1.0.0",
  "main": "server/server.js",
  "scripts": {
    "dev": "concurrently \"npm:server\" \"npm:client\"",
    "server": "node server/server.js",
    "client": "npm --prefix client run dev -- --host",
    "build": "npm --prefix client run build",
    "start": "node server/server.js",
    "test": "echo \"No automated tests configured\"",
    "lint": "npm --prefix client run lint"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "Mini web app for French vocabulary cloze practice with Azure TTS",
  "dependencies": {
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "cheerio": "^1.1.2",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "joi": "^18.0.2",
    "jsonwebtoken": "^9.0.3",
    "sqlite3": "^5.1.7",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "concurrently": "^9.2.1"
  }
}
</file>

<file path="client/src/components/ConfigModal.jsx">
import { Input, Modal, Space } from 'antd';

export default function ConfigModal({
  open,
  onClose,
  onSave,
  loading,
  azureKey,
  azureRegion,
  azureVoice,
  setAzureKey,
  setAzureRegion,
  setAzureVoice,
}) {
  return (
    <Modal
      open={open}
      title="Azure TTS 配置"
      onCancel={onClose}
      onOk={onSave}
      confirmLoading={loading}
    >
      <Space direction="vertical" style={{ width: '100%' }}>
        <Input placeholder="AZURE_SPEECH_KEY" value={azureKey} onChange={(e) => setAzureKey(e.target.value)} />
        <Input placeholder="AZURE_REGION (例如 eastasia)" value={azureRegion} onChange={(e) => setAzureRegion(e.target.value)} />
        <Input placeholder="AZURE_VOICE (例如 fr-FR-DeniseNeural)" value={azureVoice} onChange={(e) => setAzureVoice(e.target.value)} />
      </Space>
    </Modal>
  );
}
</file>

<file path="client/src/components/ImageCarousel.jsx">
import { Button, Typography } from 'antd';
import { CloseOutlined, ReloadOutlined } from '@ant-design/icons';

const { Text } = Typography;

export default function ImageCarousel({
  visible,
  state,
  position,
  onClose,
  onNext,
  onPrev,
  onRefresh,
  onWheel,
  onPreview,
  innerRef,
  onDragStart,
}) {
  if (!visible) return null;
  const { urls = [], index = 0, loading, word } = state || {};
  return (
    <div
      className="carousel-overlay"
      onWheel={onWheel}
      ref={innerRef}
      onMouseDown={onDragStart}
      style={{ top: position?.y ?? 20, left: position?.x ?? 200 }}
    >
      <Button size="small" type="text" icon={<CloseOutlined />} className="carousel-close" onClick={onClose} />
      <div className="carousel-slide">
        {loading && <Text type="secondary">图片加载中...</Text>}
        {!loading && urls.length === 0 && <Text type="secondary">暂无图片</Text>}
        {!loading && urls.length > 0 && (
          <>
            <Button className="carousel-arrow left" shape="circle" size="small" type="text" onClick={onPrev}>
              ‹
            </Button>
            <Button className="carousel-arrow right" shape="circle" size="small" type="text" onClick={onNext}>
              ›
            </Button>
            <img
              src={urls[index]}
              alt={word}
              onClick={() => {
                if (onPreview) onPreview(urls, index);
              }}
            />
            <Button
              size="small"
              type="text"
              icon={<ReloadOutlined />}
              className="carousel-refresh"
              onClick={(e) => {
                e.stopPropagation();
                onRefresh(word);
              }}
            >
            </Button>
            <div className="carousel-dots">
              {urls.map((_, i) => (
                <span key={`${word}-${i}`} className={`carousel-dot ${i === index ? 'active' : ''}`} />
              ))}
            </div>
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/constants/config.js">
export const MAX_AUTOPLAY_COUNT = 20;
export const MAX_AUTOPLAY_INTERVAL_SECONDS = 300;
export const DEFAULT_AUTOPLAY_INTERVAL_SECONDS = 1;
export const CAROUSEL_INTERVAL = 2500;
export const IMAGE_PREFETCH_CONCURRENCY = 3;
</file>

<file path="client/src/stores/useExerciseStore.js">
import { create } from 'zustand';
import { extractCandidates, buildReadingSegments, buildSegments } from '../utils/textProcessor';
import { SAMPLE_SCENE } from '../constants/defaults';

const useExerciseStore = create((set, get) => ({
  sceneText: SAMPLE_SCENE,
  selectedWords: [],
  segments: buildReadingSegments(SAMPLE_SCENE),
  showCloze: false,
  answers: {},
  statuses: {},
  wordListOpen: false,
  revealedIds: new Set(),
  setSceneText: (text) => set({ sceneText: text }),
  loadArticle: (text) => {
    set({
      sceneText: text,
      selectedWords: [],
      segments: buildReadingSegments(text),
      showCloze: false,
      answers: {},
      statuses: {},
      revealedIds: new Set(),
    });
  },
  extractWords: () => {
    const { sceneText } = get();
    const words = extractCandidates(sceneText);
    set({
      selectedWords: words,
      segments: buildSegments(sceneText, words),
      showCloze: true,
      answers: {},
      statuses: {},
    });
    return words.length;
  },
  resetCloze: () => {
    const { sceneText } = get();
    set({ showCloze: false, segments: buildReadingSegments(sceneText) });
  },
  setSelectedWords: (words) => {
    const { sceneText } = get();
    set({
      selectedWords: words,
      segments: buildSegments(sceneText, words),
    });
  },
  setAnswer: (id, value) => set((state) => ({
    answers: { ...state.answers, [id]: value },
    statuses: { ...state.statuses, [id]: undefined },
  })),
  setStatus: (id, status) => set((state) => ({
    statuses: { ...state.statuses, [id]: status },
  })),
  toggleWordList: () => set((state) => ({ wordListOpen: !state.wordListOpen })),
  setRevealedIds: (updater) => set((state) => {
    if (typeof updater === 'function') {
      return { revealedIds: updater(state.revealedIds) };
    }
    return { revealedIds: updater instanceof Set ? updater : new Set(updater || []) };
  }),
}));

export default useExerciseStore;
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/Sola.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sola</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="client/vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { VitePWA } from 'vite-plugin-pwa'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['Sola.svg'],
      manifest: {
        name: 'WordLens',
        short_name: 'WordLens',
        description: '沉浸式语言学习与完形练习',
        theme_color: '#2563eb',
        background_color: '#ffffff',
        start_url: '/',
        display: 'standalone',
        icons: [
          {
            src: '/Sola.svg',
            sizes: '512x512',
            type: 'image/svg+xml',
            purpose: 'any maskable',
          },
        ],
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
      },
    }),
  ],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5001',
        changeOrigin: true,
        secure: false,
      }
    }
  }
})
</file>

<file path="server/controllers/mediaController.js">
const imageService = require('../services/imageService');
const ttsService = require('../services/ttsService');
const userModel = require('../models/userModel');

async function getImages(req, res, next) {
  const word = (req.query.word || '').trim();
  const offset = Number(req.query.offset || 0);
  if (!word) return res.status(400).json({ error: 'Missing word' });
  try {
    const urls = await imageService.fetchImages(word, offset);
    res.json({ urls });
  } catch (err) {
    next(err);
  }
}

async function tts(req, res, next) {
  const sanitize = (val) => {
    const kept = (val || '').match(/[A-Za-zÀ-ÖØ-öø-ÿ\u4e00-\u9fff0-9]+/g);
    return kept ? kept.join(' ') : '';
  };
  const { text, voice, rate } = req.body || {};
  const cleanText = sanitize(text);
  if (!cleanText) return res.status(400).json({ error: 'Text is required' });
  try {
    const user = await userModel.findById(req.user.id);
    const data = await ttsService.synthesize(cleanText, {
      voice,
      rate,
      azureKey: user?.azure_key,
      azureRegion: user?.azure_region,
      azureVoice: user?.azure_voice,
    });
    res.json(data);
  } catch (err) {
    next(err);
  }
}

module.exports = {
  getImages,
  tts,
};
</file>

<file path=".gitignore">
node_modules
client/node_modules
client/dist
.env
server/.env
npm-debug.log*
.DS_Store
.db
</file>

<file path="client/src/hooks/useArticles.js">
import { useCallback, useEffect, useState } from 'react';
import { message } from 'antd';
import {
  listArticles,
  createArticle,
  updateArticle,
  deleteArticle,
  getArticle,
} from '../services/articleService';

export default function useArticles(enabled = true) {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(enabled);
  const [saving, setSaving] = useState(false);
  const normalizeTitle = useCallback((title) => (title || '').slice(0, 20), []);

  const load = useCallback(async () => {
    if (!enabled) return;
    setLoading(true);
    try {
      const { data } = await listArticles();
      setItems(data.items || []);
    } catch {
      message.error('加载文章失败');
    } finally {
      setLoading(false);
    }
  }, [enabled]);

  useEffect(() => {
    load();
  }, [load]);

  const createItem = async (title, content) => {
    setSaving(true);
    try {
      const safeTitle = normalizeTitle(title);
      const { data } = await createArticle(safeTitle, content);
      setItems((prev) => [data.article, ...prev]);
      message.success('创建成功');
      return data.article;
    } catch (error) {
      message.error(error.response?.data?.error || '创建失败');
      return null;
    } finally {
      setSaving(false);
    }
  };

  const updateItem = async (id, title, content) => {
    setSaving(true);
    try {
      const safeTitle = normalizeTitle(title);
      const { data } = await updateArticle(id, safeTitle, content);
      setItems((prev) => prev.map((it) => (it.id === id ? data.article : it)));
      message.success('更新成功');
      return data.article;
    } catch (error) {
      message.error(error.response?.data?.error || '更新失败');
      return null;
    } finally {
      setSaving(false);
    }
  };

  const deleteItem = async (id) => {
    setSaving(true);
    try {
      await deleteArticle(id);
      setItems((prev) => prev.filter((it) => it.id !== id));
      message.success('已删除');
    } catch (error) {
      message.error(error.response?.data?.error || '删除失败');
    } finally {
      setSaving(false);
    }
  };

  const fetchItem = useCallback(async (id) => {
    try {
      const { data } = await getArticle(id);
      return data.article;
    } catch (error) {
      if (error?.response?.status !== 404) {
        message.error('加载文章失败');
      }
      return null;
    }
  }, []);

  return {
    items,
    loading,
    saving,
    load,
    createItem,
    updateItem,
    deleteItem,
    fetchItem,
  };
}
</file>

<file path="client/src/services/mediaService.js">
import api from '../api';

// TTS 请求文本清洗：
// - 去掉所有标点/符号（节省 token）
// - 压缩空白
// - 纯中文（无拉丁字母）时去掉所有空白
const sanitizeText = (value) => {
  const normalized = String(value ?? '').replace(/\u00a0/g, ' ');
  const tokens = normalized.match(/[A-Za-z\u00C0-\u024F\u4E00-\u9FFF0-9]+/g) || [];
  const hasCjk = tokens.some((t) => /[\u4E00-\u9FFF]/.test(t));
  const hasLatin = tokens.some((t) => /[A-Za-z\u00C0-\u024F]/.test(t));
  if (hasCjk && !hasLatin) return tokens.join('');
  return tokens.join(' ').replace(/\s+/g, ' ').trim();
};

export const tts = (text, voice, rate) => api.post('/api/tts', { text: sanitizeText(text), voice, rate });

export const fetchImages = (word, offset = 0) => api.get('/api/images', { params: { word, offset } });
</file>

<file path="client/src/stores/useConfigStore.js">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const useConfigStore = create(persist((set) => ({
  autoCarousel: false,
  blurWords: false,
  accentCheck: false,
  autoPlayCount: 1,
  autoPlayCountCn: 1,
  autoPlayIntervalSeconds: 1,
  shadowingEnabled: false,
  shadowingSequence: [0.6, 0.8, 1.0, 1.0],
  backgroundPlaybackEnabled: true,
  sleepTimerMinutes: 0,
  sleepTimerEndAt: null,
  azureKey: '',
  azureRegion: '',
  azureVoice: '',
  themeMode: 'light',
  setConfig: (payload) => set(payload),
  setAutoCarousel: (val) => set({ autoCarousel: val }),
  setBlurWords: (val) => set({ blurWords: val }),
  setAccentCheck: (val) => set({ accentCheck: val }),
  setAutoPlayCount: (val) => set({ autoPlayCount: val }),
  setAutoPlayCountCn: (val) => set({ autoPlayCountCn: val }),
  setAutoPlayIntervalSeconds: (val) => set({ autoPlayIntervalSeconds: val }),
  setShadowingEnabled: (val) => set({ shadowingEnabled: val }),
  setShadowingSequence: (val) => set({ shadowingSequence: Array.isArray(val) ? val : [] }),
  setBackgroundPlaybackEnabled: (val) => set({ backgroundPlaybackEnabled: val }),
  setSleepTimerMinutes: (val) => set({ sleepTimerMinutes: val }),
  setSleepTimerEndAt: (val) => set({ sleepTimerEndAt: val }),
  setAzureKey: (val) => set({ azureKey: val }),
  setAzureRegion: (val) => set({ azureRegion: val }),
  setAzureVoice: (val) => set({ azureVoice: val }),
  setThemeMode: (val) => set({ themeMode: val }),
}), { name: 'wordlens-config' }));

export default useConfigStore;
</file>

<file path="client/src/utils/textProcessor.js">
// 逻辑：匹配一个“单词”，后面可选跟上“空格+单词”的组合（不跨行）
export const wordPattern = /[a-zA-Z\u00C0-\u024F'’-]+(?:[ \t]+[a-zA-Z\u00C0-\u024F'’-]+)*/g;

export const articleSet = new Set([
  'un',
  'une',
  'des',
  'du',
  'de',
  'le',
  'la',
  'les',
  "l'",
  'l’',
  "d'",
  'd’',
  'au',
  'aux',
  "qu'",
  'qu’',
  "c'",
  'c’',
  "s'",
  's’',
]);

export const reflexiveSet = new Set(['se', "s'", 's’', 'me', "m'", 'm’', 'te', "t'", 't’', 'nous', 'vous']);

export const fixedCombos = ['en général'];

export const fixedComboFirsts = new Set(fixedCombos.map((c) => c.split(' ')[0]));

export const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

const CHINESE_CHAR = /[\u4E00-\u9FFF]/;
const LATIN_CHAR = /[A-Za-z\u00C0-\u024F]/;
// 仅拆句号/感叹号/问号/冒号及换行，保持分隔符本身；并把标点后的空格归到标点里，避免下一段以空格开头
const CN_PUNCT_SPLIT = /([。｡.！？!?:：?][ \t]*|(?:\r?\n)+)/;
const DIGIT = /[0-9]/;

const splitChineseText = (value) => {
  if (!value) return [];
  if (!CHINESE_CHAR.test(value) && !LATIN_CHAR.test(value)) return [value];
  return value
    .split(CN_PUNCT_SPLIT)
    .filter((part) => part !== '');
};

export function segmentByLanguage(text) {
  const segments = [];
  let lastIndex = 0;
  for (const match of text.matchAll(wordPattern) || []) {
    const start = match.index || 0;
    const end = start + match[0].length;
    if (start > lastIndex) {
      const non = text.slice(lastIndex, start);
      splitChineseText(non).forEach((part) => {
        if (part) segments.push({ type: 'nonfr', value: part });
      });
    }
    const fr = (match[0] || '').trim();
    if (fr) segments.push({ type: 'fr', value: fr });
    lastIndex = end;
  }
  if (lastIndex < text.length) {
    const tail = text.slice(lastIndex);
    splitChineseText(tail).forEach((part) => {
      if (part) segments.push({ type: 'nonfr', value: part });
    });
  }
  return segments;
}

export function extractCandidates(text) {
  const matches = [...(text.matchAll(wordPattern) || [])];
  const seen = new Set();
  const results = [];

  matches.forEach((m) => {
    const raw = m[0] || '';
    const cleaned = raw
      .replace(/^[^A-Za-z\u00C0-\u024F]+|[^A-Za-z\u00C0-\u024F]+$/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    if (!cleaned || cleaned.length < 2) return;
    const key = cleaned.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    results.push(cleaned);
  });

  return results;
}

const detectChunkType = (value) => {
  if (!value) return 'punct';
  if (CHINESE_CHAR.test(value)) return 'cn';
  if (LATIN_CHAR.test(value)) return 'fr';
  // 标点、空白、数字等
  return 'punct';
};

const normalizeSegments = (parts) => {
  let textId = 0;
  let order = 0;
  return parts.flatMap((part) => {
    if (part.type === 'blank') {
      order += 1;
      return [{
        index: order - 1,
        id: part.id,
        role: 'blank',
        type: 'fr',
        value: part.value,
      }];
    }
    return splitChineseText(part.value).map((textPart) => {
      textId += 1;
      order += 1;
      return {
        index: order - 1,
        id: `chunk-${textId}`,
        role: 'text',
        type: detectChunkType(textPart),
        value: textPart,
      };
    });
  });
};

const normalizeFlatSegments = (parts) => {
  let textId = 0;
  let order = 0;
  return (parts || [])
    .filter((part) => part && typeof part.value === 'string' && part.value !== '')
    .map((part) => {
      textId += 1;
      order += 1;
      return {
        index: order - 1,
        id: `chunk-${textId}`,
        role: 'text',
        type: part.type || detectChunkType(part.value),
        value: part.value,
      };
    });
};

export function buildSegments(text, targets) {
  const safeTargets = (targets || []).filter(Boolean);
  if (!safeTargets.length) {
    return normalizeSegments([{ type: 'text', value: text }]);
  }
  const escaped = safeTargets.map((w) => escapeRegex(w)).join('|');
  const regex = new RegExp(`(${escaped})`, 'gi');
  const parts = [];
  let lastIndex = 0;
  let blankId = 0;
  text.replace(regex, (match, _p, offset) => {
    if (offset > lastIndex) {
      parts.push({ type: 'text', value: text.slice(lastIndex, offset) });
    }
    blankId += 1;
    parts.push({ type: 'blank', value: match, id: blankId });
    lastIndex = offset + match.length;
    return match;
  });
  if (lastIndex < text.length) {
    parts.push({ type: 'text', value: text.slice(lastIndex) });
  }
  return normalizeSegments(parts);
}

export function buildReadingSegments(text) {
  const source = text || '';
  if (!source) return [];
  // 先按句号/感叹号/问号/冒号/换行拆出“大块”（标点保留在块末尾），再在块内按语言拆分
  const tokens = source.split(CN_PUNCT_SPLIT).filter((part) => part !== '');
  const parts = [];

  const classifyDigit = (value, idx) => {
    const seekPrev = () => {
      for (let i = idx - 1; i >= 0; i -= 1) {
        const ch = value[i];
        if (ch === ' ' || ch === '\t' || ch === '\u00a0') continue;
        if (DIGIT.test(ch)) continue;
        return ch;
      }
      return '';
    };
    const seekNext = () => {
      for (let i = idx + 1; i < value.length; i += 1) {
        const ch = value[i];
        if (ch === ' ' || ch === '\t' || ch === '\u00a0') continue;
        if (DIGIT.test(ch)) continue;
        return ch;
      }
      return '';
    };
    const prevChar = seekPrev();
    const nextChar = seekNext();
    if (LATIN_CHAR.test(prevChar) || LATIN_CHAR.test(nextChar)) return 'fr';
    if (CHINESE_CHAR.test(prevChar) || CHINESE_CHAR.test(nextChar)) return 'cn';
    return 'cn';
  };

  const splitByLanguageRuns = (value) => {
    const runs = [];
    let currentType = null;
    let buffer = '';
    const flush = () => {
      if (!buffer) return;
      runs.push({ type: currentType || detectChunkType(buffer), value: buffer });
      buffer = '';
      currentType = null;
    };

    for (let i = 0; i < value.length; i += 1) {
      const ch = value[i];
      let nextType = null;
      if (CHINESE_CHAR.test(ch)) {
        nextType = 'cn';
      } else if (LATIN_CHAR.test(ch)) {
        nextType = 'fr';
      } else if (DIGIT.test(ch)) {
        nextType = classifyDigit(value, i);
      } else if (ch === '\u00a0' || ch === ' ' || ch === '\t') {
        // 空白归到当前块，避免产生碎片
        nextType = currentType;
      } else {
        // 其它符号（括号/逗号等）优先归到当前块；没有当前块就先归中文块，避免与外语混读时断裂
        nextType = currentType || 'cn';
      }

      if (!currentType) {
        currentType = nextType;
        buffer += ch;
        continue;
      }
      if (nextType && nextType !== currentType) {
        flush();
        currentType = nextType;
      }
      buffer += ch;
    }
    flush();
    return runs;
  };

  tokens.forEach((token) => {
    // 换行/分隔标点（含尾随空格）直接挂到上一段末尾，避免产生“纯标点”的词块
    if (/^(?:\r?\n)+$/.test(token) || /^[。｡.！？!?:：?]/.test(token)) {
      const last = parts[parts.length - 1];
      if (last) last.value += token;
      return;
    }
    splitByLanguageRuns(token).forEach((run) => {
      if (run.value) parts.push(run);
    });
  });

  // 把不包含中文/外语/数字的碎片（例如孤立标点/括号/空白）并入相邻块，避免展示成独立词块
  const merged = [];
  let prefixBuffer = '';
  const isMeaningful = (value) => CHINESE_CHAR.test(value) || LATIN_CHAR.test(value) || DIGIT.test(value);

  parts.forEach((part) => {
    if (!part?.value) return;
    if (isMeaningful(part.value)) {
      if (prefixBuffer) {
        part.value = `${prefixBuffer}${part.value}`;
        prefixBuffer = '';
      }
      merged.push(part);
      return;
    }
    if (merged.length) {
      merged[merged.length - 1].value += part.value;
    } else {
      prefixBuffer += part.value;
    }
  });
  if (prefixBuffer && merged.length) {
    merged[merged.length - 1].value += prefixBuffer;
  }

  return normalizeFlatSegments(merged);
}
</file>

<file path="client/src/hooks/useTtsAudio.js">
import { useCallback, useEffect, useRef } from 'react';
import { message } from 'antd';
import { tts } from '../services/mediaService';

export default function useTtsAudio() {
  const audioCache = useRef({});
  const audioRef = useRef(null);
  const pendingResolverRef = useRef(null);
  const playbackTokenRef = useRef(0);
  const mediaSessionReadyRef = useRef(false);
  const CACHE_KEY = 'wordlens-audio-cache';

  const sanitizeText = (text) => (text || '')
    .replace(/\u00a0/g, ' ') // nbsp -> space
    .replace(/\s+/g, ' ')
    .trim();

  const sanitizeForTts = (text) => {
    const normalized = sanitizeText(text);
    if (!normalized) return '';
    const hasCjk = /[\u4E00-\u9FFF]/.test(normalized);
    const hasLatin = /[A-Za-z\u00C0-\u024F]/.test(normalized);
    if (hasCjk && !hasLatin) {
      return normalized.replace(/[\s\u00a0]+/g, '');
    }
    return normalized;
  };

  const cleanupAudio = () => {
    if (audioRef.current) {
      audioRef.current.onended = null;
      audioRef.current.onerror = null;
    }
    audioRef.current = null;
  };

  const stop = useCallback(() => {
    playbackTokenRef.current += 1;
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
      cleanupAudio();
    }
    if (typeof navigator !== 'undefined' && navigator.mediaSession) {
      navigator.mediaSession.playbackState = 'paused';
    }
    if (pendingResolverRef.current) {
      const resolver = pendingResolverRef.current;
      pendingResolverRef.current = null;
      resolver();
    }
  }, []);

  const loadCache = useCallback(() => {
    if (typeof window === 'undefined') return {};
    try {
      const raw = window.localStorage.getItem(CACHE_KEY);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === 'object' ? parsed : {};
    } catch {
      return {};
    }
  }, [CACHE_KEY]);

  const persistCache = useCallback((cache) => {
    if (typeof window === 'undefined') return;
    try {
      window.localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
    } catch {
      // ignore quota errors, keep in-memory cache
    }
  }, [CACHE_KEY]);

  useEffect(() => {
    audioCache.current = loadCache();
  }, [loadCache]);

  const ensureAudio = async (word, voice, rate = 1.0) => {
    const normalized = sanitizeForTts(word);
    if (!normalized) throw new Error('文本为空，无法生成音频');
    const rateKey = Number.isFinite(Number(rate)) ? Number(rate).toFixed(2) : '1.00';
    const key = `${voice || ''}:${rateKey}:${normalized.toLowerCase()}`;
    if (audioCache.current[key]) return audioCache.current[key];
    const { data } = await tts(normalized, voice, rate);
    if (!data?.audioBase64) throw new Error('未收到音频，请检查 Azure 配置');
    const url = `data:${data.format || 'audio/mp3'};base64,${data.audioBase64}`;
    audioCache.current[key] = url;
    persistCache(audioCache.current);
    return url;
  };

  const playAudioUrl = (url) => new Promise((resolve) => {
    cleanupAudio();
    const audio = new Audio(url);
    audioRef.current = audio;
    const finalize = () => {
      if (pendingResolverRef.current === resolve) {
        pendingResolverRef.current = null;
      }
      cleanupAudio();
      if (typeof navigator !== 'undefined' && navigator.mediaSession) {
        navigator.mediaSession.playbackState = 'paused';
      }
      resolve();
    };
    pendingResolverRef.current = resolve;
    audio.onended = finalize;
    audio.onerror = finalize;
    audio.play().then(() => {
      if (typeof navigator !== 'undefined' && navigator.mediaSession) {
        navigator.mediaSession.playbackState = 'playing';
      }
    }).catch(finalize);
  });

  const playWord = async (word, times = 1, voice, options = {}) => {
    const normalized = sanitizeForTts(word);
    if (!normalized) return;
    const gapMs = Number(options?.gapMs) || 0;
    const rate = Number.isFinite(Number(options?.rate)) ? Number(options.rate) : 1.0;
    const onSpeedChange = typeof options?.onSpeedChange === 'function' ? options.onSpeedChange : null;
    const shouldAbort = typeof options?.shouldAbort === 'function' ? options.shouldAbort : null;
    const playbackToken = playbackTokenRef.current + 1;
    playbackTokenRef.current = playbackToken;
    try {
      if (shouldAbort && shouldAbort()) return;
      if (typeof navigator !== 'undefined' && navigator.mediaSession) {
        if (!mediaSessionReadyRef.current) {
          try {
            navigator.mediaSession.setActionHandler('play', () => {
              if (audioRef.current) {
                audioRef.current.play().catch(() => {});
              }
            });
            navigator.mediaSession.setActionHandler('pause', () => {
              if (audioRef.current) {
                audioRef.current.pause();
              }
            });
            navigator.mediaSession.setActionHandler('stop', () => {
              stop();
            });
          } catch {
            // ignore unsupported action handlers
          }
          mediaSessionReadyRef.current = true;
        }
        if (typeof window !== 'undefined' && window.MediaMetadata) {
          navigator.mediaSession.metadata = new window.MediaMetadata({
            title: normalized,
            artist: voice || 'WordLens',
            album: 'Shadowing',
          });
        }
      }
      const url = await ensureAudio(normalized, voice, rate);
      for (let i = 0; i < times; i += 1) {
        if (shouldAbort && shouldAbort()) break;
        if (playbackTokenRef.current !== playbackToken) break;
        if (onSpeedChange) onSpeedChange(rate);
        await playAudioUrl(url);
        if (shouldAbort && shouldAbort()) break;
        if (playbackTokenRef.current !== playbackToken) break;
        if (gapMs > 0 && i < times - 1) {
          let remaining = gapMs;
          while (remaining > 0) {
            if (shouldAbort && shouldAbort()) return;
            if (playbackTokenRef.current !== playbackToken) break;
            const step = Math.min(250, remaining);
            await new Promise((resolve) => setTimeout(resolve, step));
            remaining -= step;
          }
        }
      }
    } catch (error) {
      const detail = error.response?.data?.message || error.response?.data?.error || error.message;
      const status = error.response?.status;
      message.error(`调用 Azure TTS 失败${status ? ` (${status})` : ''}${detail ? `: ${detail}` : ''}`);
      throw error;
    }
  };

  return {
    playWord,
    ensureAudio,
    audioCache,
    stop,
  };
}
</file>

<file path="client/src/components/ArticleList.jsx">
import { useState } from 'react';
import {
  Button,
  Card,
  Dropdown,
  Input,
  Select,
  Modal,
  Space,
  Typography,
  Switch,
  Avatar,
  Checkbox,
  message,
} from 'antd';
import {
  MenuFoldOutlined,
  MenuUnfoldOutlined,
  UserOutlined,
  EditOutlined,
  DeleteOutlined,
  PlusOutlined,
  MoreOutlined,
  RollbackOutlined,
} from '@ant-design/icons';

const { Text } = Typography;
const MAX_TITLE_LEN = 20;
const MAX_CONTENT_LEN = 20000;

export default function ArticleList({
  items,
  loading,
  saving,
  onCreate,
  onCreateStart = () => {},
  onUpdate,
  onDelete,
  onSelect,
  activeId,
  collapsed = false,
  onToggleCollapse = () => {},
  userEmail = '',
  themeMode = 'light',
  onToggleTheme = () => {},
  onOpenConfig = () => {},
  onOpenShadowingConfig = () => {},
  onOpenStudyStats = () => {},
  backgroundPlaybackEnabled = true,
  onToggleBackgroundPlayback = () => {},
  sleepTimerMinutes = 0,
  onSleepTimerMinutesChange = () => {},
  onLogout = () => {},
  fetchItem = null,
  onLogoClick = () => {},
}) {
  const [modalOpen, setModalOpen] = useState(false);
  const [editing, setEditing] = useState(null);
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [bulkMode, setBulkMode] = useState(false);
  const [selectedIds, setSelectedIds] = useState(new Set());
  const [detailLoading, setDetailLoading] = useState(false);
  const [collapseHover, setCollapseHover] = useState(false);

  const openModal = async (item = null) => {
    if (!item) return;
    setEditing(item);
    setTitle((item?.title || '').slice(0, MAX_TITLE_LEN));
    setContent((item?.content || '').slice(0, MAX_CONTENT_LEN));
    setModalOpen(true);
    if (!item?.content && fetchItem) {
      setDetailLoading(true);
      try {
        const detail = await fetchItem(item.id);
        if (detail) {
          setEditing(detail);
          setTitle((detail.title || item.title || '').slice(0, MAX_TITLE_LEN));
          setContent((detail.content || '').slice(0, MAX_CONTENT_LEN));
        }
      } finally {
        setDetailLoading(false);
      }
    }
  };

  const submit = async () => {
    if (!title.trim() || !content.trim()) return;
    if (content.length > MAX_CONTENT_LEN) {
      message.warning(`内容最多 ${MAX_CONTENT_LEN} 个字符`);
      setContent(content.slice(0, MAX_CONTENT_LEN));
      return;
    }
    if (editing) {
      const updated = await onUpdate(editing.id, title, content);
      if (updated) onSelect(updated);
    } else {
      const created = await onCreate(title, content);
      if (created) onSelect(created);
    }
    setModalOpen(false);
  };

  const userMenuItems = [
    {
      key: 'background',
      label: (
        <div className="menu-switch" onClick={(e) => e.stopPropagation()}>
          <span>后台播放</span>
          <Switch size="small" checked={backgroundPlaybackEnabled} onChange={onToggleBackgroundPlayback} />
        </div>
      ),
    },
    {
      key: 'sleep-timer',
      label: (
        <div className="menu-switch" onClick={(e) => e.stopPropagation()}>
          <span>定时关闭</span>
          <Select
            size="small"
            value={sleepTimerMinutes}
            style={{ width: 110 }}
            onChange={(v) => onSleepTimerMinutesChange(v)}
            options={[
              { value: 0, label: '不关闭' },
              { value: 15, label: '15 分钟' },
              { value: 30, label: '30 分钟' },
              { value: 60, label: '60 分钟' },
            ]}
          />
        </div>
      ),
    },
    { key: 'stats', label: '学习统计' },
    { key: 'config', label: 'TTS 配置' },
    { key: 'shadowing-config', label: '影子跟读' },
    {
      key: 'theme',
      label: (
        <div className="menu-switch">
          <span>暗色模式</span>
          <Switch size="small" checked={themeMode === 'dark'} onChange={(checked) => onToggleTheme(checked ? 'dark' : 'light')} />
        </div>
      ),
    },
    { type: 'divider' },
    { key: 'logout', label: '退出登录' },
  ];

  const handleMenuClick = ({ key }) => {
    if (key === 'stats') onOpenStudyStats();
    if (key === 'config') onOpenConfig();
    if (key === 'shadowing-config') onOpenShadowingConfig();
    if (key === 'logout') onLogout();
  };

  const startBulk = () => {
    setBulkMode(true);
    setSelectedIds(new Set(items.map((i) => i.id)));
  };

  const handleBulkToggle = async () => {
    if (!bulkMode) {
      startBulk();
      return;
    }
    const ids = Array.from(selectedIds);
    if (!ids.length) {
      setBulkMode(false);
      return;
    }
    Modal.confirm({
      title: '确认删除选中的文章？',
      okText: '删除',
      okType: 'danger',
      cancelText: '取消',
      onOk: async () => {
        await Promise.all(ids.map((id) => onDelete(id)));
        message.success('批量删除完成');
        setBulkMode(false);
        setSelectedIds(new Set());
        const remaining = items.filter((item) => !ids.includes(item.id));
        if (remaining.length) {
          onSelect(remaining[0]);
        } else {
          onCreateStart();
        }
      },
    });
  };

  const toggleOne = (id, checked) => {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (checked) next.add(id);
      else next.delete(id);
      return next;
    });
  };

  const handleToggleAll = (checked) => {
    if (checked) {
      setSelectedIds(new Set(items.map((item) => item.id)));
    } else {
      setSelectedIds(new Set());
    }
  };

  return (
    <Card
      className={`sidebar-card ${collapsed ? 'collapsed' : ''}`}
      title={collapsed ? null : (
        <button type="button" className="logo-button" onClick={onLogoClick}>
          <img src="/Sola.svg" alt="logo" className="sidebar-logo" />
        </button>
      )}
      variant="outlined"
      extra={(
        <Space size="small">
          <Button
            type="text"
            size="small"
            className="collapse-btn"
            icon={collapsed ? (
              collapseHover ? <MenuUnfoldOutlined /> : <img src="/Sola.svg" alt="logo" className="collapse-logo" />
            ) : <MenuFoldOutlined />}
            onClick={onToggleCollapse}
            onMouseEnter={() => setCollapseHover(true)}
            onMouseLeave={() => setCollapseHover(false)}
          />
        </Space>
      )}
      loading={loading}
    >
      {!collapsed && (
        <>
          <div className="sidebar-quick-actions">
            <Button
              type="text"
              block
              className="quick-action-btn"
              icon={<PlusOutlined />}
              onClick={onCreateStart}
            >
              新增文章
            </Button>
            <Button
              type="text"
              block
              className={`quick-action-btn ${bulkMode ? (selectedIds.size ? 'danger' : 'cancel') : ''}`}
              icon={bulkMode ? <RollbackOutlined /> : <DeleteOutlined />}
              onClick={handleBulkToggle}
            >
              {bulkMode
                ? (selectedIds.size ? '完成批量删除' : '取消批量删除')
                : '批量删除'}
            </Button>
            {bulkMode && (
              <div className="bulk-toggle-all">
                <Checkbox
                  checked={selectedIds.size === items.length && items.length > 0}
                  indeterminate={selectedIds.size > 0 && selectedIds.size < items.length}
                  onChange={(e) => handleToggleAll(e.target.checked)}
                >
                  全选
                </Checkbox>
              </div>
            )}
          </div>
          <div className="sidebar-scroll" style={{ overflowX: 'hidden' }}>
            <div className="article-list">
              {items.length === 0 && <Text type="secondary">暂无文章，点击新增创建</Text>}
              {items.map((item) => (
                <div
                  key={item.id}
                  className={`article-row ${activeId === item.id ? 'active' : ''}`}
                onClick={() => onSelect(item)}
              >
                {bulkMode && (
                  <Checkbox
                    checked={selectedIds.has(item.id)}
                    onChange={(e) => {
                      e.stopPropagation();
                      toggleOne(item.id, e.target.checked);
                    }}
                  />
                )}
                <Text className="article-title" ellipsis={{ tooltip: item.title }}>{item.title}</Text>
                <Dropdown
                  trigger={['click']}
                  placement="bottomRight"
                  menu={{
                    items: [
                      { key: 'edit', label: '编辑', icon: <EditOutlined /> },
                      { key: 'delete', label: '删除', icon: <DeleteOutlined />, danger: true },
                    ],
                    onClick: ({ key, domEvent }) => {
                      domEvent.stopPropagation();
                      if (key === 'edit') {
                        openModal(item);
                      } else if (key === 'delete') {
                        Modal.confirm({
                          title: '确认删除？',
                          okText: '删除',
                          okType: 'danger',
                          cancelText: '取消',
                          onOk: () => onDelete(item.id),
                        });
                      }
                    },
                  }}
                >
                  <Button
                    type="text"
                    size="small"
                    className="article-more-btn"
                    icon={<MoreOutlined />}
                    onClick={(e) => e.stopPropagation()}
                  />
                </Dropdown>
              </div>
            ))}
          </div>
          </div>
        </>
      )}

      <Dropdown menu={{ items: userMenuItems, onClick: handleMenuClick }} placement="topLeft" trigger={['click']}>
        <div className="sidebar-footer">
          <Avatar size="small" icon={<UserOutlined />} />
          {!collapsed && (
            <div className="sidebar-footer-text">
              <Text strong>{userEmail || '未登录'}</Text>
            </div>
          )}
        </div>
      </Dropdown>

      <Modal
        title={editing ? '编辑文章' : '新增文章'}
        open={modalOpen}
        onCancel={() => setModalOpen(false)}
        onOk={submit}
        confirmLoading={saving || detailLoading}
        destroyOnHidden
      >
        <Space direction="vertical" style={{ width: '100%' }}>
          <Input
            placeholder="标题"
            value={title}
            maxLength={MAX_TITLE_LEN}
            onChange={(e) => setTitle((e.target.value || '').slice(0, MAX_TITLE_LEN))}
          />
          <Input.TextArea
            placeholder="文章内容"
            rows={8}
            value={content}
            maxLength={MAX_CONTENT_LEN}
            onChange={(e) => setContent((e.target.value || '').slice(0, MAX_CONTENT_LEN))}
          />
        </Space>
      </Modal>
    </Card>
  );
}
</file>

<file path="client/src/components/ExerciseBoard.jsx">
import { Button, Divider, Input, Popover, Space, Steps, Tag, Typography, Tooltip, message } from 'antd';
import { PictureOutlined, ReloadOutlined, CopyOutlined, CopyFilled, QuestionCircleOutlined } from '@ant-design/icons';

const { Text } = Typography;

const splitOuterWhitespace = (value) => {
  const raw = value == null ? '' : String(value);
  const leadingMatch = raw.match(/^[\s\u00a0]+/);
  const trailingMatch = raw.match(/[\s\u00a0]+$/);
  const leading = leadingMatch ? leadingMatch[0] : '';
  const trailing = trailingMatch ? trailingMatch[0] : '';
  const core = raw.replace(/^[\s\u00a0]+|[\s\u00a0]+$/g, '');
  return { leading, core, trailing };
};

const clamp = (min, val, max) => Math.max(min, Math.min(max, val));

const computeBlankWidth = (value) => {
  const raw = String(value ?? '').trim();
  if (!raw) return '80px';
  const normalized = raw.replace(/\s+/g, ' ');
  const len = normalized.length;
  // Use ch units so the box visually matches text length across fonts; keep within reasonable bounds.
  const widthCh = clamp(6, len + 2, 34);
  return `${widthCh}ch`;
};

export default function ExerciseBoard({
  segments,
  statuses,
  answers,
  showCloze,
  wordListOpen,
  selectedWords,
  blurWords,
  revealedIds,
  activeIndex,
  shadowingEnabled = false,
  shadowingSequence = [],
  currentPlayingSpeed = null,
  onToggleWordList,
  onCopyArticle,
  onInputChange,
  onInputKeyDown,
  onInputValidate = () => {},
  onInputFocus,
  onChunkActivate,
  onKeyNavigate,
  imageMap,
  fetchImages,
  onPlay,
  loadingWord,
  registerInputRef,
  onPreview,
  registerChunkRef = () => {},
}) {
  const speedTone = (rate) => {
    if (!Number.isFinite(rate)) return 'normal';
    if (rate < 0.9) return 'slow';
    if (rate > 1.05) return 'fast';
    return 'normal';
  };
  const shadowingSteps = Array.isArray(shadowingSequence) ? shadowingSequence : [];
  const getShadowingStepIndex = () => {
    if (!shadowingSteps.length || !Number.isFinite(currentPlayingSpeed)) return 0;
    const exact = shadowingSteps.findIndex((val) => Number(val) === Number(currentPlayingSpeed));
    if (exact >= 0) return exact;
    let closest = 0;
    let closestDelta = Math.abs(Number(shadowingSteps[0]) - Number(currentPlayingSpeed));
    for (let i = 1; i < shadowingSteps.length; i += 1) {
      const delta = Math.abs(Number(shadowingSteps[i]) - Number(currentPlayingSpeed));
      if (delta < closestDelta) {
        closestDelta = delta;
        closest = i;
      }
    }
    return closest;
  };
  const stepIndex = getShadowingStepIndex();
  const handleChunkKey = (e, segment) => {
    const target = e.target;
    const tag = target?.tagName?.toLowerCase?.();
    if (tag === 'input' || tag === 'textarea' || target?.isContentEditable) return;
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      onChunkActivate(segment);
    }
  };
  const handleCopyBlanks = async () => {
    const fallbackWords = segments
      .filter((segment) => segment.role === 'blank' && segment.type !== 'punct')
      .map((segment) => String(segment.value || '').trim())
      .filter(Boolean);
    const words = selectedWords?.length ? selectedWords : fallbackWords;
    if (!words.length) {
      message.info('暂无外语语块可复制');
      return;
    }
    try {
      await navigator.clipboard.writeText(words.join('\n'));
      message.success('复制外语语块成功');
    } catch {
      message.error('复制失败，请检查浏览器权限');
    }
  };
  const handleCopySegment = async (segment) => {
    const text = String(segment?.value || '').trim();
    if (!text) {
      message.info('暂无可复制内容');
      return;
    }
    try {
      await navigator.clipboard.writeText(text);
      message.success('句子已复制');
    } catch {
      message.error('复制失败，请检查浏览器权限');
    }
  };

  return (
    <>
      <div className="cloze" tabIndex={0} onKeyDown={onKeyNavigate}>
        {segments.map((segment, idx) => {
          const key = `${segment.id}-${segment.index}-${idx}`;
          const isBlank = segment.role === 'blank';
          const status = isBlank ? statuses[segment.id] : undefined;
          const entry = isBlank ? imageMap[segment.value.toLowerCase()] : null;
          const isActive = segment.index === activeIndex;
          const isPunct = segment.type === 'punct';
          const isShadowingActive = shadowingEnabled
            && segment.type === 'fr'
            && isActive
            && Number.isFinite(Number(currentPlayingSpeed));
          const speedClass = isShadowingActive ? `shadowing-${speedTone(Number(currentPlayingSpeed))}` : '';
          const chunkClass = [
            'chunk-item',
            isBlank ? 'blank chunk-blank' : 'chunk-text',
            `chunk-${segment.type}`,
            isPunct ? 'chunk-punct' : '',
            isActive && !isPunct ? 'chunk-active' : '',
            isShadowingActive ? 'chunk-shadowing' : '',
            speedClass,
          ].filter(Boolean).join(' ');

          if (!isBlank) {
            const { leading, core, trailing } = splitOuterWhitespace(segment.value);
            if (!core) {
              return (
                <span key={key} className="cloze-text">
                  {segment.value}
                </span>
              );
            }
            const isForeign = segment.type === 'fr' && !isPunct;
            const isBlurred = blurWords && isForeign && !revealedIds.has(segment.id);
            const decoratedChunkClass = `${chunkClass}${isBlurred ? ' chunk-blurred' : ''}`;
            return (
              <span key={key} className="chunk-wrap">
                {leading && <span className="cloze-text">{leading}</span>}
                <span
                  className={decoratedChunkClass}
                  ref={(el) => registerChunkRef(segment.index, el)}
                  onClick={() => {
                    if (!isPunct) onChunkActivate(segment);
                  }}
                  onKeyDown={(e) => {
                    if (!isPunct) handleChunkKey(e, segment);
                  }}
                  role={isPunct ? undefined : 'button'}
                  tabIndex={isPunct ? -1 : 0}
                >
                  <span className="cloze-text">{core}</span>
                  <Tooltip title="复制句子">
                    <Button
                      size="small"
                      type="text"
                      icon={<CopyOutlined />}
                      className="chunk-copy-btn"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleCopySegment(segment);
                      }}
                    />
                  </Tooltip>
                  {isShadowingActive && (
                    <Tag
                      className={`shadowing-tag shadowing-tag-${speedTone(Number(currentPlayingSpeed))}`}
                      color="processing"
                    >
                      {Number(currentPlayingSpeed).toFixed(1)}x
                    </Tag>
                  )}
                </span>
                {trailing && <span className="cloze-text">{trailing}</span>}
              </span>
            );
          }

          const imageContent = (
            <div className="image-grid">
              {entry?.loading && <Text type="secondary">加载中...</Text>}
              {!entry?.loading && entry?.error && <Text type="danger">{entry.error}</Text>}
              {!entry?.loading && !entry?.error && !entry?.urls?.length && <Text type="secondary">暂无图片</Text>}
              {!entry?.loading && entry?.urls?.length > 0 && (
                <>
                  {entry.urls.map((src, i) => (
                    <img
                      key={src || i}
                      src={src}
                      alt={segment.value}
                      className="image-thumb"
                      onClick={() => onPreview(entry.urls, i)}
                    />
                  ))}
                </>
              )}
              <div className="image-actions">
                <Button
                  size="small"
                  type="link"
                  icon={<ReloadOutlined />}
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    fetchImages(segment.value, true);
                  }}
                >
                  换一组
                </Button>
              </div>
            </div>
          );
          return (
            <span
              key={key}
              className={chunkClass}
              ref={(el) => registerChunkRef(segment.index, el)}
              onClick={() => onChunkActivate(segment)}
              onKeyDown={(e) => handleChunkKey(e, segment)}
              role="button"
              tabIndex={showCloze ? -1 : 0}
            >
              {showCloze ? (
                <>
                  <Input
                    size="small"
                    className={`blank-input ${status || ''}`}
                    placeholder=""
                    value={answers[segment.id] || ''}
                    onChange={(e) => onInputChange(segment.id, e.target.value)}
                    onKeyDown={(e) => onInputKeyDown(e, segment)}
                    onPressEnter={(e) => onInputKeyDown(e, segment)}
                    onBlur={(e) => {
                      onInputValidate(segment, e.target.value);
                    }}
                    onFocus={() => onInputFocus(segment)}
                    style={{ width: computeBlankWidth(segment.value) }}
                    ref={(el) => {
                      registerInputRef(segment.id, el);
                    }}
                  />
                  {!isPunct && (
                    <Tooltip title="复制句子">
                      <Button
                        size="small"
                        type="text"
                        icon={<CopyOutlined />}
                        className="chunk-copy-btn"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleCopySegment(segment);
                        }}
                      />
                    </Tooltip>
                  )}
                  {isShadowingActive && (
                    <Tag
                      className={`shadowing-tag shadowing-tag-${speedTone(Number(currentPlayingSpeed))}`}
                      color="processing"
                    >
                      {Number(currentPlayingSpeed).toFixed(1)}x
                    </Tag>
                  )}
                </>
              ) : (
                <span
                  className={`word-audio ${blurWords && !revealedIds.has(segment.id) ? 'blurred' : ''}`}
                >
                  {segment.value}
                </span>
              )}
              {showCloze && (
                <Popover trigger="hover" content={imageContent} onOpenChange={(open) => open && fetchImages(segment.value)}>
                  <Button
                    size="small"
                    type="text"
                    icon={<PictureOutlined />}
                    onClick={(e) => e.stopPropagation()}
                  />
                </Popover>
              )}
              {showCloze && (
                <Popover
                  content={(
                    <div className="shadowing-popover">
                      <Text>{segment.value}</Text>
                      {isShadowingActive && shadowingSteps.length > 0 && (
                        <>
                          <div className="shadowing-popover-meta">
                            <Tag color="processing">
                              Shadowing: {Number(currentPlayingSpeed).toFixed(1)}x
                            </Tag>
                          </div>
                          <Steps
                            size="small"
                            current={stepIndex}
                            items={shadowingSteps.map((rate) => ({ title: `${Number(rate).toFixed(1)}x` }))}
                          />
                        </>
                      )}
                    </div>
                  )}
                  trigger="click"
                >
                  <Button
                    size="small"
                    type="text"
                    icon={<QuestionCircleOutlined />}
                    loading={loadingWord === segment.value}
                    onClick={(e) => {
                      e.stopPropagation();
                      onPlay(segment.value);
                    }}
                  />
                </Popover>
              )}
            </span>
          );
        })}
      </div>
      <Divider />
      <Space size="small" wrap align="center">
        <Tooltip title="全文复制">
          <Button size="small" type="text" icon={<CopyOutlined />} onClick={onCopyArticle} />
        </Tooltip>
        <Tooltip title="复制外语语块">
          <Button size="small" type="text" icon={<CopyFilled />} onClick={handleCopyBlanks} />
        </Tooltip>
      </Space>
      <br/>
      <br/>
      <br/>
      <br/>
      <br/>
      <br/>
    </>
  );
}
</file>

<file path="client/src/components/HeroSection.jsx">
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Button, Dropdown, InputNumber, Space, Switch, Typography, Tooltip } from 'antd';
import {
  EllipsisOutlined,
  PlayCircleOutlined,
  PauseOutlined,
  EyeOutlined,
  EyeInvisibleOutlined,
  FormOutlined,
  RedoOutlined,
  RetweetOutlined,
  SwapOutlined,
  ArrowUpOutlined,
  ArrowDownOutlined,
  ArrowLeftOutlined,
  ArrowRightOutlined,
  ShrinkOutlined,
  DoubleRightOutlined,
  DoubleLeftOutlined,
  RollbackOutlined,
} from '@ant-design/icons';

const { Text } = Typography;

export default function HeroSection({
  onToggleMode = () => {},
  showCloze,
  onReadAll,
  onTogglePause,
  isPlaying,
  isPaused,
  onMoveShortcut,
  autoPlayCount,
  setAutoPlayCount,
  autoPlayCountCn = 1,
  setAutoPlayCountCn = () => {},
  autoPlayIntervalSeconds = 1,
  setAutoPlayIntervalSeconds = () => {},
  isSentenceLooping = false,
  onToggleSentenceLoop = () => {},
  isForeignLooping = false,
  onToggleForeignLoop = () => {},
  isSingleSentenceLooping = false,
  onToggleSingleSentenceLoop = () => {},
  shadowingEnabled = false,
  onToggleShadowing = () => {},
  onShadowingAction = () => {},
  prefetchAudio,
  prefetching,
  prefetchProgress,
  prefetchChinese,
  prefetchingCn,
  prefetchProgressCn,
  prefetchImages,
  imagePrefetching,
  imagePrefetchProgress,
  autoCarousel,
  blurWords,
  accentCheck,
  setAutoCarousel,
  setBlurWords,
  setAccentCheck,
  isMobile = false,
  onOpenConfig = () => {},
  onOpenShadowingConfig = () => {},
  onOpenStudyStats = () => {},
  onLogout = () => {},
  onMenuConfig = null,
}) {
  const prefetchAudioRef = useRef(prefetchAudio);
  const prefetchChineseRef = useRef(prefetchChinese);
  const prefetchImagesRef = useRef(prefetchImages);
  const openConfigRef = useRef(onOpenConfig);
  const openStudyStatsRef = useRef(onOpenStudyStats);
  const logoutRef = useRef(onLogout);
  const controlPulseRef = useRef(null);
  const [activeControl, setActiveControl] = useState(null);
  const [navPanelOpen, setNavPanelOpen] = useState(false);

  useEffect(() => { prefetchAudioRef.current = prefetchAudio; }, [prefetchAudio]);
  useEffect(() => { prefetchChineseRef.current = prefetchChinese; }, [prefetchChinese]);
  useEffect(() => { prefetchImagesRef.current = prefetchImages; }, [prefetchImages]);
  useEffect(() => { openConfigRef.current = onOpenConfig; }, [onOpenConfig]);
  useEffect(() => { openStudyStatsRef.current = onOpenStudyStats; }, [onOpenStudyStats]);
  useEffect(() => { logoutRef.current = onLogout; }, [onLogout]);
  useEffect(() => () => {
    if (controlPulseRef.current) {
      clearTimeout(controlPulseRef.current);
      controlPulseRef.current = null;
    }
  }, []);

  const controlSize = isMobile ? 'middle' : 'large';
  const switchSize = isMobile ? 'default' : 'large';
  const handleToggleMode = useCallback((checked) => {
    onToggleMode(checked);
  }, [onToggleMode]);
  const menuItems = useMemo(() => {
    const base = [
      {
        key: 'count-cn',
        label: (
          <div className="hero-menu-row" onClick={(e) => e.stopPropagation()}>
            <Text>自动中文发音次数</Text>
            <InputNumber
              size="small"
              min={0}
              max={20}
              value={autoPlayCountCn}
              onChange={(v) => setAutoPlayCountCn(v || 0)}
              style={{ width: 80 }}
            />
          </div>
        ),
      },
      {
        key: 'count',
        label: (
          <div className="hero-menu-row" onClick={(e) => e.stopPropagation()}>
            <Text>自动外语发音次数</Text>
            <InputNumber
              size="small"
              min={0}
              max={20}
              value={autoPlayCount}
              onChange={(v) => setAutoPlayCount(v || 0)}
              style={{ width: 80 }}
            />
          </div>
        ),
      },
      {
        key: 'interval',
        label: (
          <div className="hero-menu-row" onClick={(e) => e.stopPropagation()}>
            <Text>自动发音间隔(秒)</Text>
            <InputNumber
              size="small"
              min={0}
              max={300}
              value={autoPlayIntervalSeconds}
              onChange={(v) => setAutoPlayIntervalSeconds(v ?? 0)}
              style={{ width: 80 }}
            />
          </div>
        ),
      },
      {
        key: 'audio',
        label: '缓存外语音频',
        disabled: prefetching,
        tip: '缓存当前文章所有外语音频',
      },
      {
        key: 'audio-cn',
        label: '缓存中文音频',
        disabled: prefetchingCn,
        tip: '缓存当前文章所有中文音频',
      },
      {
        key: 'image',
        label: '缓存轮播图',
        disabled: imagePrefetching,
        tip: '缓存当前文章所有轮播图',
      },
      {
        key: 'accent',
        label: (
          <div className="hero-menu-row" onClick={(e) => e.stopPropagation()}>
            <Text>重音检查</Text>
            <Switch size="small" checked={accentCheck} onChange={setAccentCheck} />
          </div>
        ),
        tip: '用于控制填写练习是否检查法语重音符',
      },
    ];
    if (isMobile) {
      base.unshift(
        {
          key: 'mode',
          label: (
            <div className="hero-menu-row" onClick={(e) => e.stopPropagation()}>
              <Text>练习模式</Text>
              <Switch
                size="small"
                checked={showCloze}
                onChange={handleToggleMode}
                checkedChildren={<FormOutlined />}
                unCheckedChildren={<RedoOutlined />}
              />
            </div>
          ),
        },
        {
          key: 'blur',
          label: (
            <div className="hero-menu-row" onClick={(e) => e.stopPropagation()}>
              <Text>单词遮挡</Text>
              <Switch
                size="small"
                checked={blurWords}
                onChange={setBlurWords}
                checkedChildren={<EyeInvisibleOutlined />}
                unCheckedChildren={<EyeOutlined />}
              />
            </div>
          ),
        },
        {
          key: 'shadowing',
          label: (
            <div className="hero-menu-row" onClick={(e) => e.stopPropagation()}>
              <Text>影子跟读</Text>
              <Switch
                size="small"
                checked={shadowingEnabled}
                onChange={onToggleShadowing}
                checkedChildren={<ShrinkOutlined />}
                unCheckedChildren={<ShrinkOutlined />}
              />
            </div>
          ),
        },
        {
          key: 'carousel',
          label: (
            <div className="hero-menu-row" onClick={(e) => e.stopPropagation()}>
              <Text>图片轮播</Text>
              <Switch
                size="small"
                checked={autoCarousel}
                onChange={setAutoCarousel}
                checkedChildren={<RetweetOutlined />}
                unCheckedChildren={<RetweetOutlined />}
              />
            </div>
          ),
        },
      );
      // keep this divider only when we later add mobile-specific sections
    }
    return base;
  }, [
    accentCheck,
    autoCarousel,
    autoPlayCount,
    autoPlayCountCn,
    autoPlayIntervalSeconds,
    blurWords,
    handleToggleMode,
    imagePrefetching,
    isMobile,
    prefetching,
    prefetchingCn,
    onToggleShadowing,
    setAccentCheck,
    setAutoCarousel,
    setAutoPlayCount,
    setAutoPlayCountCn,
    setAutoPlayIntervalSeconds,
    setBlurWords,
    shadowingEnabled,
    showCloze,
  ]);

  const wrappedMenuItems = useMemo(() => menuItems.map((item) => {
    if (!item.tip) return item;
    return {
      ...item,
      label: (
        <Tooltip title={item.tip} placement="left">
          <span>{item.label}</span>
        </Tooltip>
      ),
    };
  }), [menuItems]);

  const handleMenuClick = useCallback(({ key }) => {
    if (key === 'audio') prefetchAudioRef.current();
    if (key === 'audio-cn') prefetchChineseRef.current();
    if (key === 'image') prefetchImagesRef.current();
    if (key === 'stats') openStudyStatsRef.current();
    if (key === 'config') openConfigRef.current();
    if (key === 'shadowing-config') onOpenShadowingConfig();
    if (key === 'logout') logoutRef.current();
  }, [onOpenShadowingConfig]);
  const menuProps = useMemo(() => ({
    items: wrappedMenuItems,
    onClick: handleMenuClick,
  }), [handleMenuClick, wrappedMenuItems]);
  const menuPropsRef = useRef(menuProps);
  useEffect(() => {
    menuPropsRef.current = menuProps;
  }, [menuProps]);
  const menuSignature = useMemo(() => JSON.stringify({
    autoPlayCount,
    autoPlayCountCn,
    autoPlayIntervalSeconds,
    prefetching,
    prefetchingCn,
    imagePrefetching,
    accentCheck,
    showCloze,
    blurWords,
    shadowingEnabled,
    autoCarousel,
    isMobile,
  }), [
    accentCheck,
    autoCarousel,
    autoPlayCount,
    autoPlayCountCn,
    autoPlayIntervalSeconds,
    blurWords,
    imagePrefetching,
    isMobile,
    prefetching,
    prefetchingCn,
    shadowingEnabled,
    showCloze,
  ]);

  useEffect(() => {
    if (!onMenuConfig) return;
    if (isMobile) onMenuConfig(menuPropsRef.current);
    else onMenuConfig(null);
  }, [isMobile, menuSignature, onMenuConfig]);

  const isActivePlaying = isPlaying && !isPaused;
  const showReadAll = false;
  const pulseControl = useCallback((key, handler) => {
    if (controlPulseRef.current) {
      clearTimeout(controlPulseRef.current);
      controlPulseRef.current = null;
    }
    setActiveControl(key);
    handler();
    controlPulseRef.current = setTimeout(() => {
      setActiveControl((prev) => (prev === key ? null : prev));
      controlPulseRef.current = null;
    }, 320);
  }, []);
  const handleOpenNavPanel = useCallback(() => {
    setNavPanelOpen(true);
  }, []);
  const handleCloseNavPanel = useCallback(() => {
    setNavPanelOpen(false);
  }, []);
  const handlePrimaryAction = useCallback(() => {
    if (isActivePlaying) {
      onTogglePause();
      return;
    }
    if (isPaused) {
      onTogglePause();
      return;
    }
    onReadAll();
  }, [isActivePlaying, isPaused, onReadAll, onTogglePause]);

  const switchBlock = isMobile ? null : (
    <Space size="small" wrap align="center" className="hero-switches">
      <Tooltip title="练习模式(听写/原文)">
        <Switch
          size={switchSize}
          checked={showCloze}
          onChange={handleToggleMode}
          checkedChildren={<FormOutlined />}
          unCheckedChildren={<RedoOutlined />}
        />
      </Tooltip>
      <Tooltip title="图片轮播">
        <Switch
          size={switchSize}
          checked={autoCarousel}
          onChange={setAutoCarousel}
          checkedChildren={<RetweetOutlined />}
          unCheckedChildren={<RetweetOutlined />}
        />
      </Tooltip>
      <Tooltip title="单词遮挡">
        <Switch
          size={switchSize}
          checked={blurWords}
          onChange={setBlurWords}
          checkedChildren={<EyeInvisibleOutlined />}
          unCheckedChildren={<EyeOutlined />}
        />
      </Tooltip>
    </Space>
  );

  return (
    <div className={`hero-header ${isMobile ? 'hero-mobile' : ''}`}>
      <div className="hero-toolbar">
        {!isMobile && <div className="hero-section hero-section-start" />}
        <div className="hero-section hero-section-center">
          <Space
            size={isMobile ? 'large' : 'large'}
            wrap={!isMobile}
            direction="horizontal"
            align="center"
            className="hero-control-space"
          >
            <Space size="small" wrap align="center" className="hero-control-buttons">
              {showReadAll && (
                <Tooltip title={isActivePlaying ? '暂停' : (isPaused ? '继续' : '全文朗读')}>
                  <Button
                    size={controlSize}
                    type="text"
                    icon={isActivePlaying ? <PauseOutlined /> : <PlayCircleOutlined />}
                    onClick={handlePrimaryAction}
                  />
                </Tooltip>
              )}
              <div className={`hero-loop-group ${navPanelOpen ? 'collapsed' : ''}`}>
                <Tooltip title={isSentenceLooping ? '停止全文循环' : '全文循环'}>
                  <Button
                    size={controlSize}
                    type="text"
                    icon={<RetweetOutlined />}
                    className={isSentenceLooping || activeControl === 'loop-sentence' ? 'hero-loop-active hero-control-active' : ''}
                    onClick={() => pulseControl('loop-sentence', onToggleSentenceLoop)}
                  />
                </Tooltip>
                <Tooltip title={isForeignLooping ? '停止外语循环' : '外语循环'}>
                  <Button
                    size={controlSize}
                    type="text"
                    icon={<SwapOutlined />}
                    className={isForeignLooping || activeControl === 'loop-foreign' ? 'hero-loop-active hero-control-active' : ''}
                    onClick={() => pulseControl('loop-foreign', onToggleForeignLoop)}
                  />
                </Tooltip>
                <Tooltip title={isSingleSentenceLooping ? '停止单句循环' : '单句循环'}>
                  <Button
                    size={controlSize}
                    type="text"
                    icon={<RollbackOutlined />}
                    className={isSingleSentenceLooping || activeControl === 'loop-single' ? 'hero-loop-active hero-control-active' : ''}
                    onClick={() => pulseControl('loop-single', onToggleSingleSentenceLoop)}
                  />
                </Tooltip>
                <Tooltip title="影子跟读">
                  <Button
                    size={controlSize}
                    type="text"
                    icon={<ShrinkOutlined />}
                    className={shadowingEnabled || activeControl === 'shadowing' ? 'hero-control-active' : ''}
                    onClick={() => pulseControl('shadowing', onShadowingAction)}
                  />
                </Tooltip>
                <Button
                  size={controlSize}
                  type="text"
                  icon={<DoubleRightOutlined />}
                  className={activeControl === 'nav-open' ? 'hero-control-active' : ''}
                  onClick={() => pulseControl('nav-open', handleOpenNavPanel)}
                />
              </div>
              <div className={`hero-nav-group ${navPanelOpen ? 'expanded' : ''}`}>
                <Button
                  size={controlSize}
                  type="text"
                  icon={<DoubleLeftOutlined />}
                  className={activeControl === 'nav-close' ? 'hero-control-active' : ''}
                  onClick={() => pulseControl('nav-close', handleCloseNavPanel)}
                />
                <Tooltip title="上一个外语词块(快捷键:↑)">
                  <Button
                    size={controlSize}
                    type="text"
                    icon={<ArrowUpOutlined />}
                    className={activeControl === 'arrow-up' ? 'hero-control-active' : ''}
                    onClick={() => pulseControl('arrow-up', () => onMoveShortcut(-1, 'foreign'))}
                  />
                </Tooltip>
                <Tooltip title="下一个外语词块(快捷键:↓)">
                  <Button
                    size={controlSize}
                    type="text"
                    icon={<ArrowDownOutlined />}
                    className={activeControl === 'arrow-down' ? 'hero-control-active' : ''}
                    onClick={() => pulseControl('arrow-down', () => onMoveShortcut(1, 'foreign'))}
                  />
                </Tooltip>
                <Tooltip title="上一个词块(快捷键:←)">
                  <Button
                    size={controlSize}
                    type="text"
                    icon={<ArrowLeftOutlined />}
                    className={activeControl === 'arrow-left' ? 'hero-control-active' : ''}
                    onClick={() => pulseControl('arrow-left', () => onMoveShortcut(-1, 'all'))}
                  />
                </Tooltip>
                <Tooltip title="下一个词块(快捷键:→)">
                  <Button
                    size={controlSize}
                    type="text"
                    icon={<ArrowRightOutlined />}
                    className={activeControl === 'arrow-right' ? 'hero-control-active' : ''}
                    onClick={() => pulseControl('arrow-right', () => onMoveShortcut(1, 'all'))}
                  />
                </Tooltip>
              </div>
            </Space>
            {switchBlock}
            <div className="hero-progress">
              {prefetching && (
                <Text type="secondary" style={{ marginRight: 12 }}>
                  外语 {prefetchProgress.done}/{prefetchProgress.total}
                </Text>
              )}
              {prefetchingCn && (
                <Text type="secondary" style={{ marginRight: 12 }}>
                  中文 {prefetchProgressCn.done}/{prefetchProgressCn.total}
                </Text>
              )}
              {imagePrefetching && (
                <Text type="secondary">
                  图片 {imagePrefetchProgress.done}/{imagePrefetchProgress.total}
                </Text>
              )}
            </div>
          </Space>
        </div>

        {!isMobile && (
          <div className="hero-section hero-section-end">
            <Dropdown menu={menuProps} trigger={['click']} placement="bottomRight">
              <Button type="text" icon={<EllipsisOutlined />} />
            </Dropdown>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/App.css">
@import url('https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap');

:root {
  --bg: #f3f6fb;
  --surface: #fff;
  --sidebar: #f9f9f9;
  --accent: #2563eb;
  --text: #0f172a;
  --muted: #475569;
  --border: rgba(0, 0, 0, 0.06);
}

[data-theme='dark'] {
  --bg: #0c111c;
  --surface: #0f172a;
  --sidebar: #0f172a;
  --accent: #60a5fa;
  --text: #e5e7eb;
  --muted: #94a3b8;
  --border: rgba(255, 255, 255, 0.08);
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  background: var(--bg);
  font-family: 'Manrope', system-ui, -apple-system, sans-serif;
  color: var(--text);
  overflow: hidden;
}

body[data-theme='dark'] {
  background: #0c111c;
}

html,
body,
#root {
  height: 100%;
}

#root {
  padding: 0;
}

.app-layout {
  display: flex;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  background: var(--bg);
}

.app-sidebar {
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  background: var(--sidebar);
  border-right: 1px solid var(--border);
  padding: 0;
  flex-shrink: 0;
  transition: width 180ms ease, min-width 180ms ease;
}

.app-sidebar.collapsed {
  overflow: hidden;
}

.app-sidebar::-webkit-scrollbar {
  width: 6px;
}

.app-sidebar::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.15);
  border-radius: 6px;
}

.app-main {
  flex: 1;
  height: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  position: relative;
}

.main-header {
  flex-shrink: 0;
  background: var(--surface);
  z-index: 10;
  box-shadow: none;
}

.main-scroll-area {
  flex: 1;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  display: flex;
  flex-direction: column;
  align-items: center;
  background: var(--surface);
  padding: 20px 0 48px;
}

.article-panel {
  flex: 1;
  min-height: 0;
  width: 100%;
  max-width: 980px;
  margin: 0 auto;
  background: transparent;
  border: none;
  border-radius: 0;
  padding: 12px 0;
  box-shadow: none;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.new-article-shell {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 60vh;
  position: relative;
  margin-top: 100px;
}

.new-article-form {
  width: 50%;
  max-width: 1080px;
  min-width: 780px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 60px 0 80px;
  position: relative;
}

.bubble-form {
  background: transparent;
  border-radius: 18px;
  padding: 0;
  box-shadow: none;
}

.bubble-heading {
  display: block;
  font-size: 30px;
  color: var(--text);
  margin-bottom: 14px;
  text-align: center;
}

.typing-text {
  display: block;
  min-height: 40px;
  font-size: 26px;
  letter-spacing: 1px;
  color: var(--text);
}

.auth-typing {
  text-align: center;
  margin-bottom: 18px;
  font-size: 22px;
  color: var(--text);
}

.bubble-input {
  width: 100%;
  border: none;
  outline: none;
  background: transparent;
  color: var(--text);
}

.title-input {
  display: none;
}

.title-input::placeholder {
  color: #c5c5c5;
  font-weight: 700;
}

.bubble-body {
  position: relative;
  background: #fff;
  border-radius: 22px;
  padding: 10px 16px;
  border: 1px solid #e5e7eb;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
  display: flex;
  flex-direction: column;
  gap: 8px;
  min-height: 64px;
}

.body-input {
  min-height: 120px;
  font-size: 16px;
  line-height: 1.7;
  resize: none;
  border: none;
  border-radius: 0;
  padding: 0;
  background: transparent;
  flex: 1;
}

.body-input::placeholder {
  color: #b3b3b3;
}

.input-error {
  border: 1px solid #ef4444 !important;
  border-radius: 8px;
  padding: 4px 8px;
}

.input-error-text {
  color: #ef4444;
  font-size: 12px;
  margin-top: 4px;
}


.bubble-actions {
  display: flex;
  justify-content: flex-end;
}

.article-panel-head {
  position: sticky;
  top: 0;
  z-index: 5;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 2px 6px;
  background: var(--surface);
}

.article-title-text {
  font-weight: 700;
  font-size: 16px;
}

.new-article-actions {
  position: absolute;
  top: 16px;
  right: 0;
  display: flex;
  gap: 10px;
}

.content-container {
  width: 100%;
  max-width: 1080px;
  padding: 16px 24px 24px;
  box-sizing: border-box;
  min-height: 100%;
  display: flex;
  flex-direction: column;
}

.header-container {
  padding-top: 16px;
  padding-bottom: 12px;
  max-width: none;
  width: 100%;
}

.page {
  max-width: 1200px;
  margin: 0 auto 48px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.hero {
  background: linear-gradient(120deg, #f8fbff, #edf2ff);
  border: 1px solid rgba(37, 99, 235, 0.08);
  box-shadow: 0 16px 50px rgba(37, 99, 235, 0.12);
}

.hero h2 {
  color: #0b1b36 !important;
}

.auth-wrap {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(180deg, #f9fbff 0%, #eef2f8 100%);
}

.auth-card {
  width: 340px;
}

.auth-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.hero p {
  color: #334155 !important;
}

.hero-header {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.hero-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  width: 100%;
}

.hero-control-buttons,
.hero-switches {
  display: flex;
}

.hero-control-buttons {
  justify-content: center;
}

.hero-loop-group,
.hero-nav-group {
  display: flex;
  align-items: center;
  gap: 8px;
  overflow: hidden;
  transition: opacity 180ms ease, max-width 200ms ease, transform 200ms ease;
}

.hero-loop-group {
  max-width: 240px;
}

.hero-loop-group.collapsed {
  max-width: 0;
  opacity: 0;
  transform: translateX(-6px);
  pointer-events: none;
}

.hero-nav-group {
  max-width: 0;
  opacity: 0;
  transform: translateX(6px);
  pointer-events: none;
}

.hero-nav-group.expanded {
  max-width: 320px;
  opacity: 1;
  transform: translateX(0);
  pointer-events: auto;
}

.hero-switches {
  align-items: center;
  gap: 16px;
}

.hero-switches .ant-switch {
  transform: scale(1.15);
}

.hero-header.hero-mobile {
  border-radius: 18px;
  border: 1px solid var(--border);
  box-shadow: 0 12px 32px rgba(15, 23, 42, 0.25);
}

.hero-control-space {
  width: 100%;
}

.hero-control-buttons .ant-btn {
  min-width: 44px;
  height: 44px;
  font-size: 18px;
}

.hero-control-buttons .ant-btn .anticon {
  font-size: 20px;
}

.hero-loop-active,
.hero-control-active {
  color: #22c55e !important;
}

.mobile-top-bar,
.mobile-toolbar-shell {
  display: none;
}

.hero-progress {
  min-height: 18px;
  color: var(--muted);
}

.hero-section {
  display: flex;
  align-items: center;
}

.hero-section-start,
.hero-section-end {
  flex: 1;
}

.hero-section-start {
  justify-content: flex-start;
}

.hero-section-center {
  flex: 0 0 auto;
  justify-content: center;
}

.hero-section-end {
  justify-content: flex-end;
}

.workspace-side {
  flex: 0 0 260px;
  min-width: 220px;
}

.workspace-main {
  display: flex;
  flex-direction: column;
  gap: 12px;
  flex: 1;
  min-width: 0;
}

.chat-layout {
  display: flex;
  gap: 12px;
  align-items: flex-start;
  min-height: 100vh;
}

.sidebar-shell {
  position: sticky;
  top: 0;
  height: calc(100vh - 24px); /* compensate for top/bottom padding */
  background: #eef1f5;
  border-right: 1px solid rgba(0, 0, 0, 0.04);
  padding: 12px 10px;
}

.sidebar-shell.is-collapsed {
  flex-basis: 72px;
  min-width: 72px;
}

.sidebar-card {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  border: none;
  box-shadow: none;
  background: var(--sidebar);
  padding: 0;
  transition: width 180ms ease, min-width 180ms ease;
}

.sidebar-card .ant-card-head {
  padding: 8px 10px;
  border-bottom: none;
  background: var(--sidebar);
  margin: 0;
}

.sidebar-card .ant-card-body {
  padding: 6px 8px 10px;
  display: flex;
  flex-direction: column;
  flex: 1;
  min-height: 0;
  background: var(--sidebar);
}

.sidebar-scroll {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 6px;
  margin-bottom: 8px;
}

.sidebar-quick-actions {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 6px 0 10px;
}

.bulk-toggle-all {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 10px 0;
}

.quick-action-btn {
  display: flex !important;
  align-items: center;
  justify-content: flex-start;
  gap: 10px;
  padding: 6px 10px !important;
  border-radius: 8px;
  font-weight: 600;
  color: var(--text) !important;
}

.quick-action-btn:hover {
  background: rgba(15, 23, 42, 0.08);
}

.quick-action-btn.danger {
  color: #dc2626 !important;
}

.quick-action-btn.cancel {
  color: #2563eb !important;
}

.chat-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 12px;
  min-width: 0;
}

.op-panel {
  position: sticky;
  top: 0;
  z-index: 10;
  border-radius: 0;
  border: none;
  box-shadow: none;
  background: #f9fafb;
  padding: 8px 0 6px;
}

.article-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 4px 0;
}

.article-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 8px;
  border-radius: 6px;
  transition: background 120ms;
  cursor: pointer;
  gap: 8px;
}

.article-row:hover {
  background: rgba(15, 23, 42, 0.06);
}

.article-row.active {
  background: rgba(37, 99, 235, 0.12);
}

.article-more-btn {
  opacity: 0;
  transition: opacity 120ms;
}

.article-row:hover .article-more-btn,
.article-row.active .article-more-btn {
  opacity: 1;
}

.sidebar-logo {
  height: 20px;
  background: transparent;
  display: block;
}

.logo-button {
  border: none;
  background: transparent;
  padding: 0;
  margin: 0;
  cursor: pointer;
}

.article-title {
  flex: 1;
  font-weight: 600;
  color: var(--text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.article-actions .ant-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
}

.sidebar-footer {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  border-top: 1px solid transparent;
  cursor: pointer;
  margin-top: auto;
  position: sticky;
  bottom: 0;
  background: var(--sidebar);
  box-shadow: none;
  min-height: 48px;
}

.sidebar-footer:hover {
  background: rgba(37, 99, 235, 0.08);
}

.sidebar-footer-text {
  display: flex;
  flex-direction: column;
  line-height: 1.2;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  
}

.sidebar-card.collapsed {
  width: 60px;
  min-width: 60px;
}

.sidebar-card.collapsed .sidebar-scroll,
.sidebar-card.collapsed .ant-card-head-title {
  display: none;
}

.sidebar-card.collapsed .ant-card-head {
  padding: 6px 0;
  justify-content: center;
  transition: padding 180ms ease;
}

.sidebar-card.collapsed .ant-card-head-wrapper {
  width: 100%;
  justify-content: center;
}

.sidebar-card.collapsed .sidebar-footer {
  justify-content: center;
  padding: 8px 0;
  border-top: none;
  position: sticky;
  bottom: 0;
  width: 100%;
  transition: padding 180ms ease;
}

.sidebar-card .ant-card-body {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-height: 0;
}

.sidebar-card.collapsed .ant-card-body {
  padding: 6px 0 8px;
  align-items: center;
}

.sidebar-card.collapsed .sidebar-footer-text {
  display: none;
}

.sidebar-card.collapsed .ant-card-extra {
  padding: 0;
  margin: 0;
}

.sidebar-card.collapsed .ant-card-head {
  display: flex;
  align-items: center;
}

.collapse-logo {
  height: 20px;
  width: 20px;
  object-fit: contain;
}

.collapse-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
}

.user-bar {
  display: flex;
  align-items: center;
  gap: 12px;
}

.input-card {
  display: none;
}

.input-card .ant-card-head {
  min-height: 38px;
}

.input-card .ant-card-extra {
  padding: 8px 0;
}

.topbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 0;
}

.brand {
  font-weight: 700;
  font-size: 18px;
  color: var(--text);
}

.menu-switch {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  min-width: 160px;
}

.hero-menu-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  min-width: 220px;
}

.ant-card {
  background: var(--surface);
  border: none;
  color: var(--text);
  box-shadow: none;
}

.ant-typography {
  color: var(--text);
}

.ant-card-head-title {
  font-size: 14px;
}

.cloze {
  line-height: 1.8;
  font-size: 15px;
  color: var(--text);
  white-space: pre-wrap;
}

.cloze-text {
  color: var(--text);
}

.blank {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 0 2px;
  margin: 0 1px;
  background: rgba(37, 99, 235, 0.12);
  border-bottom: 1px dashed var(--accent);
  border-radius: 6px;
}

.blank .ant-btn {
  color: var(--accent);
}

.chunk-item {
  cursor: pointer;
  border-radius: 6px;
  padding: 0 2px;
  position: relative;
  transition: background 120ms, box-shadow 120ms, outline 120ms;
}

.chunk-copy-btn {
  position: absolute;
  left: -6px;
  bottom: -18px;
  opacity: 0;
  transform: translateY(2px);
  transition: opacity 160ms ease, transform 160ms ease;
}

.chunk-item:hover .chunk-copy-btn,
.chunk-item:focus-within .chunk-copy-btn {
  opacity: 1;
  transform: translateY(0);
}

.chunk-item.chunk-text {
  display: inline;
}

.chunk-item.chunk-fr {
  color: var(--accent);
  background: rgba(37, 99, 235, 0.08);
  border-bottom: 1px dashed rgba(37, 99, 235, 0.55);
}

.chunk-item.chunk-cn {
  color: var(--text);
}

.chunk-item.chunk-punct {
  cursor: default;
}

.chunk-item.chunk-blank {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.chunk-item.chunk-active {
  background: transparent;
  outline: 1px solid #f97316;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.35);
}

.chunk-item.chunk-shadowing {
  outline: 1px solid rgb(var(--shadowing-color, 52, 211, 153));
  outline-offset: 2px;
  animation: shadowingPulse 1.6s ease-in-out infinite;
}

.chunk-item.shadowing-slow {
  --shadowing-color: 96, 165, 250;
}

.chunk-item.shadowing-normal {
  --shadowing-color: 52, 211, 153;
}

.chunk-item.shadowing-fast {
  --shadowing-color: 251, 146, 60;
}

@keyframes shadowingPulse {
  0% {
    box-shadow: 0 0 0 0 rgba(var(--shadowing-color, 52, 211, 153), 0.45);
  }
  70% {
    box-shadow: 0 0 0 6px rgba(var(--shadowing-color, 52, 211, 153), 0.05);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(var(--shadowing-color, 52, 211, 153), 0.25);
  }
}

.shadowing-tag {
  position: absolute;
  top: -16px;
  right: -14px;
  margin: 0;
  padding: 0 6px;
  line-height: 18px;
  font-size: 11px;
  border-radius: 10px;
  pointer-events: none;
}

.shadowing-popover {
  display: flex;
  flex-direction: column;
  gap: 6px;
  min-width: 180px;
}

.shadowing-popover-meta {
  display: flex;
  align-items: center;
  gap: 8px;
}

.chunk-wrap {
  display: inline;
}

.chunk-item.chunk-blurred .cloze-text {
  filter: blur(6px);
  user-select: none;
  transition: filter 140ms ease;
}


.word-audio {
  color: var(--accent);
  cursor: pointer;
  padding: 0 2px;
  border-radius: 6px;
  transition: box-shadow 120ms, background 120ms, outline 120ms;
}

.word-audio.active {
  background: transparent;
  outline: 1px solid #f97316;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.35);
}

.word-audio.blurred {
  filter: blur(5px);
  user-select: none;
}

.markdown-text {
  display: inline;
}

.markdown-text .md-list {
  display: inline-block;
  padding-left: 18px;
  margin: 2px 6px;
}

.markdown-text .md-inline-code {
  background: rgba(15, 23, 42, 0.08);
  border-radius: 4px;
  padding: 1px 4px;
  font-size: 90%;
}

.blank-input {
  width: auto;
  min-width: 70px;
  max-width: 320px;
}

.blank-input.correct {
  border-color: #22c55e !important;
  background: rgba(34, 197, 94, 0.12);
  color: #16a34a !important;
  caret-color: #16a34a;
}

.blank-input.wrong {
  border-color: #ef4444 !important;
  background: rgba(239, 68, 68, 0.12);
  color: #dc2626 !important;
  caret-color: #dc2626;
}

.image-grid {
  display: grid;
  grid-template-columns: repeat(3, 80px);
  gap: 6px;
  max-width: 260px;
}

.image-thumb {
  width: 80px;
  height: 80px;
  object-fit: cover;
  border-radius: 6px;
  border: 1px solid rgba(0, 0, 0, 0.06);
  cursor: pointer;
  transition: transform 120ms;
}

.image-thumb:hover {
  transform: scale(1.03);
}

.image-actions {
  grid-column: 1 / -1;
  text-align: right;
}

.ant-input,
.ant-select,
.ant-alert {
  color: var(--text);
}

.info-tip {
  max-width: 320px;
  color: #0f172a;
}

.info-tip ol {
  padding-left: 18px;
  margin: 4px 0 10px;
}

.info-tip ol li {
  margin-bottom: 4px;
}

.carousel-overlay {
  position: fixed;
  top: 0;
  left: 0;
  display: inline-flex;
  align-items: flex-start;
  gap: 8px;
  padding: 20px;
  background: rgba(255, 255, 255, 0.96);
  border: 1px solid rgba(0, 0, 0, 0.06);
  border-radius: 12px;
  box-shadow: 0 12px 28px rgba(15, 23, 42, 0.16);
  backdrop-filter: blur(8px);
  z-index: 1200;
  cursor: move;
  user-select: none;
}

.carousel-slide {
  position: relative;
  min-width: 360px;
  max-width: 520px;
}

.carousel-slide img {
  width: 100%;
  max-height: 260px;
  object-fit: cover;
  border-radius: 10px;
  border: 1px solid rgba(0, 0, 0, 0.08);
}

.carousel-dots {
  display: flex;
  gap: 6px;
  margin-top: 6px;
  align-items: center;
  justify-content: center;
}

.carousel-dot {
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.2);
  transition: all 150ms ease;
}

.carousel-dot.active {
  width: 16px;
  background: #2563eb;
}

.carousel-close {
  position: absolute;
  top: 6px;
  right: 6px;
}

.carousel-arrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 2;
  width: 28px;
  height: 28px;
  background: rgba(255, 255, 255, 0.85);
  border-radius: 999px;
  border: 1px solid rgba(0, 0, 0, 0.08);
  box-shadow: 0 6px 18px rgba(15, 23, 42, 0.2);
}

.carousel-arrow.left {
  left: 10px;
}

.carousel-arrow.right {
  right: 10px;
}

.carousel-refresh {
  position: absolute;
  bottom: -10px;
  right: 0px;
  background:none;
  border: none;
  color: var(--text);
}

body[data-theme='dark'] .hero {
  background: linear-gradient(120deg, #0f172a, #111827);
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow: 0 16px 50px rgba(0, 0, 0, 0.45);
}

body[data-theme='dark'] .ant-card {
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
}

body[data-theme='dark'] .ant-typography {
  color: var(--text);
}

body[data-theme='dark'] .markdown-text .md-inline-code {
  background: rgba(255, 255, 255, 0.08);
}

body[data-theme='dark'] .word-audio.active {
  outline: 2px solid #fb923c;
  box-shadow: 0 0 0 3px rgba(251, 146, 60, 0.35);
}

body[data-theme='dark'] .chunk-item.chunk-active {
  outline: 2px solid #fb923c;
  box-shadow: 0 0 0 3px rgba(251, 146, 60, 0.35);
}

body[data-theme='dark'] .carousel-overlay {
  background: rgba(17, 24, 39, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

body[data-theme='dark'] .carousel-arrow {
  background: rgba(31, 41, 55, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

body[data-theme='dark'] .carousel-refresh {
  background: rgba(31, 41, 55, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

body[data-theme='dark'] .image-thumb {
  border: 1px solid rgba(255, 255, 255, 0.12);
}

@media (max-width: 1024px) {
  .content-container {
    padding-left: 20px;
    padding-right: 20px;
  }
}

@media (max-width: 768px) {
  .app-layout {
    flex-direction: column;
    height: 100dvh;
  }

  .app-main {
    width: 100%;
    height: 100%;
  }

  .content-container {
    padding: 16px;
    max-width: none;
  }

  .main-scroll-area {
    padding: 12px 0 calc(150px + env(safe-area-inset-bottom));
  }

  .mobile-top-bar {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    position: sticky;
    top: 0;
    z-index: 15;
  }

  .mobile-top-title {
    flex: 1;
    font-weight: 700;
    font-size: 16px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

.mobile-toolbar-shell {
  display: block;
  position: fixed;
  left: 0;
  right: 0;
    bottom: 0;
    padding: 0 12px calc(10px + env(safe-area-inset-bottom));
    background: linear-gradient(180deg, rgba(15, 23, 42, 0) 0%, rgba(15, 23, 42, 0.35) 70%);
    z-index: 30;
    pointer-events: none;
  }

  .mobile-toolbar-shell .hero-header {
    pointer-events: auto;
    padding: 10px 16px;
    border-radius: 26px;
    background: rgba(255, 255, 255, 0.85);
    box-shadow: 0 18px 32px rgba(15, 23, 42, 0.2);
    color: var(--text);
  }

  .mobile-toolbar-shell .hero-header .ant-btn,
  .mobile-toolbar-shell .hero-header .ant-typography {
    color: var(--text);
  }

  body[data-theme='dark'] .mobile-toolbar-shell .hero-header {
    background: rgba(15, 23, 42, 0.85);
    color: var(--text);
  }

  body[data-theme='dark'] .mobile-toolbar-shell .hero-header .ant-btn,
  body[data-theme='dark'] .mobile-toolbar-shell .hero-header .ant-typography {
    color: var(--text);
  }

  .mobile-toolbar-shell .hero-header .ant-btn {
    background: transparent;
  }

  .mobile-toolbar-shell .hero-header .ant-btn .anticon {
    color: inherit;
  }

  .mobile-toolbar-shell .hero-header .ant-btn:hover {
    background: rgba(15, 23, 42, 0.06);
  }

  body[data-theme='dark'] .mobile-toolbar-shell .hero-header .ant-btn:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  body[data-theme='dark'] .mobile-toolbar-shell .hero-header .ant-btn .anticon {
    color: var(--text);
  }

  .hero-header.hero-mobile .hero-toolbar {
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 12px;
  }

  .hero-header.hero-mobile .hero-progress {
    text-align: center;
    font-size: 13px;
  }

  .hero-control-buttons .ant-btn {
    width: 42px;
    height: 42px;
    font-size: 20px;
  }

.hero-control-buttons .ant-btn .anticon {
  font-size: 22px;
}

.hero-loop-active {
  color: #22c55e !important;
}

  .app-sidebar {
    display: none;
  }

  .cloze {
    font-size: 17px;
    line-height: 1.8;
  }

  .blank,
  .chunk-item.chunk-blank {
    min-height: 44px;
    padding: 4px 8px;
    margin: 2px;
  }

  .blank-input {
    font-size: 16px;
    padding: 6px 8px;
    max-width: 80vw;
  }

  .mobile-sidebar-drawer .ant-drawer-body {
    padding: 0;
    background: var(--sidebar);
  }

  .mobile-sidebar-drawer .ant-drawer-header,
  .mobile-sidebar-drawer .ant-drawer-close {
    display: none;
  }

  .new-article-shell {
    align-items: stretch;
    min-height: auto;
    margin-top: 16px;
    padding: 0 0 32px;
  }

  .new-article-form {
    width: 100%;
    min-width: 0;
    max-width: none;
    padding: 24px 16px 32px;
  }

  .bubble-heading,
  .typing-text {
    font-size: 22px;
  }

  .bubble-body {
    padding: 12px 14px;
  }
}

.pull-refresh-indicator {
  position: fixed;
  top: 12px;
  left: 50%;
  transform: translate(-50%, -18px);
  padding: 8px 12px;
  background: color-mix(in srgb, var(--surface) 92%, transparent);
  backdrop-filter: blur(6px);
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
  display: flex;
  align-items: center;
  gap: 10px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 150ms ease, transform 150ms ease;
  z-index: 40;
}

.pull-refresh-indicator.visible {
  opacity: 1;
  transform: translate(-50%, 0);
}

.pull-refresh-text {
  font-size: 13px;
  color: var(--text);
  white-space: nowrap;
  flex-shrink: 0;
}

.pull-refresh-icon {
  width: 18px;
  height: 18px;
  border-radius: 999px;
  border: 2px solid rgba(37, 99, 235, 0.25);
  border-top-color: var(--accent);
  will-change: transform;
  transition: transform 120ms ease;
}

.pull-refresh-icon.refreshing {
  animation: pull-refresh-spin 700ms linear infinite;
}

.pull-refresh-icon.ready {
  border-top-color: #10b981;
}

.pull-refresh-icon.pulling {
  border-top-color: var(--accent);
}

.pull-refresh-icon.idle {
  border-top-color: var(--accent);
}

.pull-refresh-bar {
  width: 90px;
  height: 4px;
  background: rgba(37, 99, 235, 0.18);
  border-radius: 999px;
  overflow: hidden;
}

.pull-refresh-bar-fill {
  height: 100%;
  width: 100%;
  background: linear-gradient(90deg, var(--accent), #22c55e);
  transform-origin: left center;
  transform: scaleX(var(--pull-progress, 0));
  transition: transform 120ms cubic-bezier(0.22, 0.61, 0.36, 1);
  will-change: transform;
}

@keyframes pull-refresh-spin {
  to {
    transform: rotate(360deg);
  }
}

.study-stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.study-stats-card {
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 14px 14px;
  background: var(--surface);
  box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
}

.study-stats-label {
  color: rgba(15, 23, 42, 0.65);
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.2px;
}

.study-stats-value {
  margin-top: 6px;
  font-size: 22px;
  font-weight: 800;
  color: var(--text);
}

@media (max-width: 768px) {
  .study-stats-grid {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="client/src/pages/DashboardPage.jsx">
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { flushSync } from 'react-dom';
import {
  Button,
  Drawer,
  Dropdown,
  Modal,
  message,
  Spin,
} from 'antd';
import { MenuOutlined, MoreOutlined } from '@ant-design/icons';
import HeroSection from '../components/HeroSection';
import ArticleList from '../components/ArticleList';
import ExerciseBoard from '../components/ExerciseBoard';
import ImageCarousel from '../components/ImageCarousel';
import ConfigModal from '../components/ConfigModal';
import ShadowingConfigModal from '../components/ShadowingConfigModal';
import { addStudyTime, getStudyStats } from '../services/userService';
import useTtsAudio from '../hooks/useTtsAudio';
import useImageSearch from '../hooks/useImageSearch';
import useArticles from '../hooks/useArticles';
import useExerciseStore from '../stores/useExerciseStore';
import useConfigStore from '../stores/useConfigStore';
import useAuthStore from '../stores/useAuthStore';
import api from '../api';
import { CAROUSEL_INTERVAL, DEFAULT_AUTOPLAY_INTERVAL_SECONDS, MAX_AUTOPLAY_COUNT, MAX_AUTOPLAY_INTERVAL_SECONDS } from '../constants/config';

export default function DashboardPage() {
  const { user, logout } = useAuthStore();
  const [configOpen, setConfigOpen] = useState(false);
  const [configLoading, setConfigLoading] = useState(false);
  const [shadowingConfigOpen, setShadowingConfigOpen] = useState(false);
  const [loadingWord, setLoadingWord] = useState('');
  const [prefetching, setPrefetching] = useState(false);
  const [prefetchProgress, setPrefetchProgress] = useState({ done: 0, total: 0 });
  const [prefetchingCn, setPrefetchingCn] = useState(false);
  const [prefetchProgressCn, setPrefetchProgressCn] = useState({ done: 0, total: 0 });
  const [activeArticle, setActiveArticle] = useState(null);
  const [pendingArticleId, setPendingArticleId] = useState(null);
  const [creating, setCreating] = useState(false);
  const [newContent, setNewContent] = useState('');
  const [contentError, setContentError] = useState('');
  const [activeIndex, setActiveIndex] = useState(-1);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [currentPlayingSpeed, setCurrentPlayingSpeed] = useState(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [previewSrc, setPreviewSrc] = useState('');
  const [previewList, setPreviewList] = useState([]);
  const [previewIndex, setPreviewIndex] = useState(0);
  const [isMobile, setIsMobile] = useState(() => (typeof window !== 'undefined' ? window.innerWidth <= 768 : false));
  const [mobileSidebarOpen, setMobileSidebarOpen] = useState(false);
  const [typedIntro] = useState('今天想背点什么？');
  const [mobileMenuProps, setMobileMenuProps] = useState(null);
  const [studyStatsOpen, setStudyStatsOpen] = useState(false);
  const [studyStatsLoading, setStudyStatsLoading] = useState(false);
  const [studyStats, setStudyStats] = useState({ todayMs: 0, totalMs: 0, day: '' });
  const tzOffsetMinutes = useMemo(() => new Date().getTimezoneOffset(), []);
  const computeDefaultCarouselPos = () => {
    const w = typeof window !== 'undefined' ? window.innerWidth : 1200;
    const h = typeof window !== 'undefined' ? window.innerHeight : 800;
    const cardW = 520;
    const cardH = 260;
    return {
      x: Math.max(20, w - 100 - cardW),
      y: Math.max(20, h / 2 - cardH / 2),
    };
  };
  const [carouselPos, setCarouselPos] = useState(() => computeDefaultCarouselPos());
  const dragOffsetRef = useRef({ x: 0, y: 0 });
  const draggingRef = useRef(false);
  const pullStartY = useRef(null);
  const pullTriggered = useRef(false);
  const mainScrollRef = useRef(null);
  const chunkRefs = useRef({});
  const refreshArticleRef = useRef(null);
  const [pullStatus, setPullStatus] = useState('idle'); // idle | pulling | ready | refreshing
  const [pullDistance, setPullDistance] = useState(0);
  // Mobile pull-to-refresh: raise thresholds to avoid accidental triggers.
  const PULL_THRESHOLD = 140;
  const PULL_ACTIVATE = 18;
  const TOP_STAY_MS = 400;
  const pullProgress = Math.min(1, Math.max(0, pullDistance / PULL_THRESHOLD));
  const pullLabel = pullStatus === 'refreshing'
    ? '刷新中...'
    : pullStatus === 'ready'
      ? '松开刷新'
      : '下拉刷新';
  const indicatorOffset = pullStatus === 'idle' ? 0 : Math.min(pullDistance, PULL_THRESHOLD * 1.2);
  const indicatorY = pullStatus === 'idle' ? -18 : Math.max(0, indicatorOffset / 3);
  const indicatorScale = pullStatus === 'refreshing' ? 1 : 0.92 + pullProgress * 0.08;
  const topEnterAtRef = useRef(null);
  const topReadyRef = useRef(false);
  useEffect(() => {
    if (typeof window === 'undefined') return undefined;
    const mq = window.matchMedia('(max-width: 768px)');
    const handleChange = (event) => {
      setIsMobile(event.matches);
    };
    handleChange(mq);
    mq.addEventListener('change', handleChange);
    return () => mq.removeEventListener('change', handleChange);
  }, []);

  useEffect(() => {
    if (!isMobile) {
      setMobileSidebarOpen(false);
    }
  }, [isMobile]);

  useEffect(() => {
    if (typeof window === 'undefined' || !isMobile) return undefined;
    const getScrollTop = () => {
      const container = mainScrollRef.current;
      return container ? container.scrollTop : window.scrollY;
    };
    const handleScroll = () => {
      const atTop = getScrollTop() <= 0;
      if (atTop) {
        if (topEnterAtRef.current == null) {
          topEnterAtRef.current = Date.now();
          topReadyRef.current = false;
        } else if (!topReadyRef.current && Date.now() - topEnterAtRef.current >= TOP_STAY_MS) {
          topReadyRef.current = true;
        }
      } else {
        topEnterAtRef.current = null;
        topReadyRef.current = false;
      }
    };
    const canTrigger = () => {
      if (getScrollTop() > 0) return false;
      if (topReadyRef.current) return true;
      const enteredAt = topEnterAtRef.current;
      if (enteredAt && Date.now() - enteredAt >= TOP_STAY_MS) {
        topReadyRef.current = true;
        return true;
      }
      return false;
    };
    const handleStart = (e) => {
      if (!canTrigger()) return;
      pullStartY.current = e.touches?.[0]?.clientY ?? null;
      pullTriggered.current = false;
      setPullStatus('idle');
      setPullDistance(0);
    };
    const handleMove = (e) => {
      if (pullStartY.current === null) return;
      const currentY = e.touches?.[0]?.clientY;
      if (typeof currentY !== 'number') return;
      const delta = currentY - pullStartY.current;
      if (delta <= 0) {
        setPullStatus('idle');
        setPullDistance(0);
        return;
      }
      setPullDistance(delta);
      if (delta < PULL_ACTIVATE) {
        setPullStatus('idle');
        pullTriggered.current = false;
        return;
      }
      if (delta >= PULL_THRESHOLD) {
        pullTriggered.current = true;
        setPullStatus('ready');
      } else {
        pullTriggered.current = false;
        setPullStatus('pulling');
      }
    };
    const handleEnd = () => {
      if (pullTriggered.current) {
        pullTriggered.current = false;
        pullStartY.current = null;
        setPullStatus('refreshing');
        setPullDistance(PULL_THRESHOLD);
        const doRefresh = refreshArticleRef.current;
        if (typeof doRefresh === 'function') {
          doRefresh();
        } else {
          window.location.reload();
        }
        return;
      }
      pullStartY.current = null;
      setPullStatus('idle');
      setPullDistance(0);
    };
    const scrollEl = mainScrollRef.current;
    handleScroll();
    window.addEventListener('scroll', handleScroll, { passive: true });
    if (scrollEl) {
      scrollEl.addEventListener('scroll', handleScroll, { passive: true });
    }
    window.addEventListener('touchstart', handleStart, { passive: true });
    window.addEventListener('touchmove', handleMove, { passive: true });
    window.addEventListener('touchend', handleEnd, { passive: true });
    return () => {
      window.removeEventListener('scroll', handleScroll);
      if (scrollEl) {
        scrollEl.removeEventListener('scroll', handleScroll);
      }
      window.removeEventListener('touchstart', handleStart);
      window.removeEventListener('touchmove', handleMove);
      window.removeEventListener('touchend', handleEnd);
    };
  }, [isMobile]);

  const updateUrl = (articleId) => {
    if (typeof window === 'undefined') return;
    const params = new URLSearchParams(window.location.search);
    if (articleId) {
      params.set('article', articleId);
    } else {
      params.delete('article');
    }
    const search = params.toString();
    const next = `${window.location.pathname}${search ? `?${search}` : ''}`;
    window.history.replaceState(null, '', next);
  };
  const [carouselState, setCarouselState] = useState({
    word: '',
    urls: [],
    index: 0,
    visible: false,
    loading: false,
  });
  const inputRefs = useRef({});
  const carouselRef = useRef(null);
  const playbackRef = useRef({ cancelled: false });
  const playRequestTokenRef = useRef(0);
  const { playWord, ensureAudio, audioCache, stop: stopAudio } = useTtsAudio();

  const cancelCurrentPlayback = useCallback((preserveActive = false) => {
    if (playbackRef.current) {
      playbackRef.current.cancelled = true;
      playbackRef.current.paused = false;
    }
    stopAudio();
    setIsPlaying(false);
    setIsPaused(false);
    setCurrentPlayingSpeed(null);
    if (!preserveActive) {
      setActiveIndex(-1);
    }
  }, [stopAudio]);
  useEffect(() => {
    if (typeof window === 'undefined') return;
    const params = new URLSearchParams(window.location.search);
    const id = params.get('article');
    if (id) {
      setPendingArticleId(id);
    }
  }, []);

  useEffect(() => () => cancelCurrentPlayback(), [cancelCurrentPlayback]);

  // fine-grained subscriptions to避免 getSnapshot警告
  const sceneText = useExerciseStore((state) => state.sceneText);
  const selectedWords = useExerciseStore((state) => state.selectedWords);
  const segments = useExerciseStore((state) => state.segments);
  const showCloze = useExerciseStore((state) => state.showCloze);
  const answers = useExerciseStore((state) => state.answers);
  const statuses = useExerciseStore((state) => state.statuses);
  const wordListOpen = useExerciseStore((state) => state.wordListOpen);
  const revealedIds = useExerciseStore((state) => state.revealedIds);

  const loadArticle = useExerciseStore((state) => state.loadArticle);
  const extractWords = useExerciseStore((state) => state.extractWords);
  const resetCloze = useExerciseStore((state) => state.resetCloze);
  const setAnswer = useExerciseStore((state) => state.setAnswer);
  const setStatus = useExerciseStore((state) => state.setStatus);
  const toggleWordList = useExerciseStore((state) => state.toggleWordList);
  const setRevealedIds = useExerciseStore((state) => state.setRevealedIds);

  const autoCarousel = useConfigStore((state) => state.autoCarousel);
  const blurWords = useConfigStore((state) => state.blurWords);
  const accentCheck = useConfigStore((state) => state.accentCheck);
  const autoPlayCount = useConfigStore((state) => state.autoPlayCount);
  const autoPlayCountCn = useConfigStore((state) => state.autoPlayCountCn);
  const autoPlayIntervalSeconds = useConfigStore((state) => state.autoPlayIntervalSeconds);
  const backgroundPlaybackEnabled = useConfigStore((state) => state.backgroundPlaybackEnabled);
  const sleepTimerMinutes = useConfigStore((state) => state.sleepTimerMinutes);
  const sleepTimerEndAt = useConfigStore((state) => state.sleepTimerEndAt);
  const shadowingEnabled = useConfigStore((state) => state.shadowingEnabled);
  const shadowingSequence = useConfigStore((state) => state.shadowingSequence);
  const azureKey = useConfigStore((state) => state.azureKey);
  const azureRegion = useConfigStore((state) => state.azureRegion);
  const azureVoice = useConfigStore((state) => state.azureVoice);
  const setAutoCarousel = useConfigStore((state) => state.setAutoCarousel);
  const setBlurWords = useConfigStore((state) => state.setBlurWords);
  const setAccentCheck = useConfigStore((state) => state.setAccentCheck);
  const setAutoPlayCount = useConfigStore((state) => state.setAutoPlayCount);
  const setAutoPlayCountCn = useConfigStore((state) => state.setAutoPlayCountCn);
  const setAutoPlayIntervalSeconds = useConfigStore((state) => state.setAutoPlayIntervalSeconds);
  const setBackgroundPlaybackEnabled = useConfigStore((state) => state.setBackgroundPlaybackEnabled);
  const setSleepTimerMinutes = useConfigStore((state) => state.setSleepTimerMinutes);
  const setSleepTimerEndAt = useConfigStore((state) => state.setSleepTimerEndAt);
  const setShadowingEnabled = useConfigStore((state) => state.setShadowingEnabled);
  const setShadowingSequence = useConfigStore((state) => state.setShadowingSequence);
  const setAzureKey = useConfigStore((state) => state.setAzureKey);
  const setAzureRegion = useConfigStore((state) => state.setAzureRegion);
  const setAzureVoice = useConfigStore((state) => state.setAzureVoice);
  const themeMode = useConfigStore((state) => state.themeMode);
  const setThemeMode = useConfigStore((state) => state.setThemeMode);

  const formatDuration = useCallback((ms) => {
    const totalMinutes = Math.max(0, Math.floor((ms || 0) / 60000));
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;
    return `${hours} 小时 ${minutes} 分钟`;
  }, []);

  const refreshStudyStats = useCallback(async () => {
    if (!user) return;
    setStudyStatsLoading(true);
    try {
      const { data } = await getStudyStats(tzOffsetMinutes);
      setStudyStats({
        todayMs: Number(data?.today_ms) || 0,
        totalMs: Number(data?.total_ms) || 0,
        day: data?.day || '',
      });
    } finally {
      setStudyStatsLoading(false);
    }
  }, [tzOffsetMinutes, user]);

  const postStudyTime = useCallback(async (deltaMs) => {
    if (!user) return;
    const { data } = await addStudyTime(deltaMs, tzOffsetMinutes);
    setStudyStats((prev) => ({
      ...prev,
      todayMs: Number(data?.today_ms) || prev.todayMs,
      totalMs: Number(data?.total_ms) || prev.totalMs,
      day: data?.day || prev.day,
    }));
  }, [tzOffsetMinutes, user]);

  const loadConfig = useCallback(async () => {
    try {
      const { data } = await api.get('/api/user/config');
      setAzureKey(data.azure_key || '');
      setAzureRegion(data.azure_region || '');
      setAzureVoice(data.azure_voice || '');
    } catch {
      message.error('加载配置失败');
    }
  }, [setAzureKey, setAzureRegion, setAzureVoice]);

  const {
    imageMap,
    loadImages,
    prefetchImages: prefetchImagesAll,
    prefetching: imagePrefetching,
    prefetchProgress: imagePrefetchProgress,
  } = useImageSearch();
  const imageMapRef = useRef({});
  useEffect(() => {
    imageMapRef.current = imageMap;
  }, [imageMap]);
  const {
    items: articles,
    loading: articlesLoading,
    saving: articlesSaving,
    load: reloadArticles,
    createItem: createArticle,
    updateItem: updateArticle,
    deleteItem: deleteArticle,
    fetchItem,
  } = useArticles(!!user);

  const blanks = useMemo(() => segments.filter((seg) => seg.role === 'blank'), [segments]);
  const clampedFrCount = Math.min(MAX_AUTOPLAY_COUNT, Math.max(0, autoPlayCount || 0));
  const clampedCnCount = Math.min(MAX_AUTOPLAY_COUNT, Math.max(0, autoPlayCountCn || 0));
  const clampedIntervalSeconds = Math.min(
    MAX_AUTOPLAY_INTERVAL_SECONDS,
    Math.max(0, Number.isFinite(Number(autoPlayIntervalSeconds)) ? Number(autoPlayIntervalSeconds) : DEFAULT_AUTOPLAY_INTERVAL_SECONDS),
  );
  const waitForPlaybackGap = useCallback((ms, controller) => new Promise((resolve) => {
    if (!ms) {
      resolve(true);
      return;
    }
    const started = Date.now();
    const tick = () => {
      if (controller?.cancelled || controller?.paused) {
        resolve(false);
        return;
      }
      const elapsed = Date.now() - started;
      if (elapsed >= ms) {
        resolve(true);
        return;
      }
      const remaining = ms - elapsed;
      const step = Math.min(250, remaining);
      setTimeout(tick, step);
    };
    tick();
  }), []);
  const buildAudioCacheKey = useCallback((text, voice, rate = 1.0) => {
    const normalized = String(text || '').trim().toLowerCase();
    const rateKey = Number.isFinite(Number(rate)) ? Number(rate).toFixed(2) : '1.00';
    return `${voice || ''}:${rateKey}:${normalized}`;
  }, []);
  const normalizedShadowingSequence = useMemo(() => {
    const raw = Array.isArray(shadowingSequence) ? shadowingSequence : [];
    const cleaned = raw
      .map((val) => (Number.isFinite(Number(val)) ? Number(val) : 1.0))
      .filter((val) => val > 0);
    return cleaned.length ? cleaned : [1.0];
  }, [shadowingSequence]);
  const sentenceLoopTokenRef = useRef(0);
  const [sentenceLooping, setSentenceLooping] = useState(false);
  const [foreignLooping, setForeignLooping] = useState(false);
  const singleSentenceLoopTokenRef = useRef(0);
  const [singleSentenceLooping, setSingleSentenceLooping] = useState(false);

  useEffect(() => {
    refreshArticleRef.current = async () => {
      try {
        const currentId = activeArticle?.id;
        await reloadArticles();
        if (currentId) {
          const detail = await fetchItem(currentId);
          if (detail) {
            setActiveArticle(detail);
          }
        }
      } finally {
        setPullStatus('idle');
        setPullDistance(0);
      }
    };
  }, [activeArticle, fetchItem, reloadArticles]);

  const copyArticle = async () => {
    try {
      await navigator.clipboard.writeText(sceneText || '');
      message.success('全文已复制');
    } catch {
      message.error('复制失败，请检查浏览器权限');
    }
  };

  const fetchImages = useCallback(async (word, refresh = false) => {
    const key = word.toLowerCase();
    const current = imageMap[key] || {};
    setCarouselState((prev) => {
      if (prev.word.toLowerCase() === key) return { ...prev, loading: true };
      return prev;
    });
    try {
      const urls = await loadImages(word, refresh);
      const nextUrls = urls || current.urls || [];
      setCarouselState((prev) => {
        if (prev.word.toLowerCase() === key) {
          return {
            ...prev,
            urls: nextUrls,
            loading: false,
            index: 0,
            visible: autoCarousel,
          };
        }
        return prev;
      });
    } catch {
      setCarouselState((prev) => {
        if (prev.word.toLowerCase() === key) {
          return { ...prev, loading: false, urls: current.urls || prev.urls || [] };
        }
        return prev;
      });
    }
  }, [autoCarousel, imageMap, loadImages]);

  useEffect(() => {
    if (user) {
      loadConfig();
    } else {
      setAzureKey('');
      setAzureRegion('');
      setAzureVoice('');
    }
  }, [loadConfig, setAzureKey, setAzureRegion, setAzureVoice, user]);

  useEffect(() => {
    if (!activeArticle) return;
    if (activeArticle.content) {
      loadArticle(activeArticle.content);
      setCreating(false);
      updateUrl(activeArticle.id);
      return;
    }
    (async () => {
      const detail = await fetchItem(activeArticle.id);
      if (detail) {
        setActiveArticle(detail);
      }
    })();
  }, [activeArticle, fetchItem, loadArticle]);

  useEffect(() => {
    inputRefs.current = {};
    cancelCurrentPlayback();
    sentenceLoopTokenRef.current += 1;
    setSentenceLooping(false);
    setForeignLooping(false);
    setPreviewList([]);
    setPreviewIndex(0);
    setCarouselState((prev) => ({ ...prev, visible: false, word: '', urls: [], loading: false }));
  }, [sceneText, selectedWords, cancelCurrentPlayback]);

  useEffect(() => {
    if (articlesLoading || !user) return;
    if (!articles.length) {
      setCreating(true);
      setActiveArticle(null);
      updateUrl(null);
      return;
    }
    if (pendingArticleId) {
      const match = articles.find((a) => String(a.id) === String(pendingArticleId));
      if (match) {
        setActiveArticle(match);
        setCreating(false);
        setPendingArticleId(null);
        return;
      }
      setPendingArticleId(null);
    }
    if (!creating && !activeArticle) {
      setActiveArticle(articles[0]);
      setCreating(false);
    }
  }, [articles, activeArticle, articlesLoading, creating, pendingArticleId, user]);

  useEffect(() => {
    if (showCloze) {
      setCarouselState((prev) => ({ ...prev, visible: false }));
    }
  }, [showCloze]);

  useEffect(() => {
    if (!studyStatsOpen) return;
    refreshStudyStats();
  }, [refreshStudyStats, studyStatsOpen]);

  useEffect(() => {
    if (typeof window === 'undefined' || !user) return undefined;
    let lastTick = Date.now();
    let pendingMs = 0;
    let flushing = false;
    const shouldTrack = () => document.visibilityState === 'visible' && window.document.hasFocus();

    const flush = async () => {
      if (flushing) return;
      const delta = pendingMs;
      if (delta < 1000) return;
      pendingMs = 0;
      flushing = true;
      try {
        await postStudyTime(delta);
      } catch {
        pendingMs += delta;
      } finally {
        flushing = false;
      }
    };

    const tick = () => {
      const now = Date.now();
      const delta = now - lastTick;
      lastTick = now;
      if (shouldTrack()) {
        pendingMs += Math.max(0, delta);
      }
      if (pendingMs >= 30000) {
        flush();
      }
    };

    const handleVisibility = () => {
      if (document.visibilityState !== 'visible') flush();
      lastTick = Date.now();
    };
    const handleBlur = () => flush();
    const handleFocus = () => { lastTick = Date.now(); };

    const timer = window.setInterval(tick, 5000);
    document.addEventListener('visibilitychange', handleVisibility);
    window.addEventListener('blur', handleBlur);
    window.addEventListener('focus', handleFocus);
    return () => {
      window.clearInterval(timer);
      document.removeEventListener('visibilitychange', handleVisibility);
      window.removeEventListener('blur', handleBlur);
      window.removeEventListener('focus', handleFocus);
      flush();
    };
  }, [postStudyTime, user]);

  const stopAllPlayback = useCallback(() => {
    sentenceLoopTokenRef.current += 1;
    setSentenceLooping(false);
    setForeignLooping(false);
    cancelCurrentPlayback(true);
  }, [cancelCurrentPlayback]);

  useEffect(() => {
    if (typeof window === 'undefined') return undefined;
    if (backgroundPlaybackEnabled) return undefined;
    const handleVisibility = () => {
      if (document.visibilityState !== 'visible') stopAllPlayback();
    };
    const handleBlur = () => stopAllPlayback();
    document.addEventListener('visibilitychange', handleVisibility);
    window.addEventListener('blur', handleBlur);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibility);
      window.removeEventListener('blur', handleBlur);
    };
  }, [backgroundPlaybackEnabled, stopAllPlayback]);

  useEffect(() => {
    if (typeof window === 'undefined') return undefined;
    if (!sleepTimerEndAt) return undefined;
    const endAt = Number(sleepTimerEndAt);
    if (!Number.isFinite(endAt)) return undefined;
    const remaining = endAt - Date.now();
    if (remaining <= 0) {
      stopAllPlayback();
      setSleepTimerMinutes(0);
      setSleepTimerEndAt(null);
      return undefined;
    }
    const timer = window.setTimeout(() => {
      stopAllPlayback();
      setSleepTimerMinutes(0);
      setSleepTimerEndAt(null);
      message.info('已到定时关闭时间，已停止播放');
    }, remaining);
    return () => window.clearTimeout(timer);
  }, [setSleepTimerEndAt, setSleepTimerMinutes, sleepTimerEndAt, stopAllPlayback]);

  const handleSleepTimerChange = useCallback((minutes) => {
    const m = Number(minutes) || 0;
    if (m <= 0) {
      setSleepTimerMinutes(0);
      setSleepTimerEndAt(null);
      return;
    }
    setSleepTimerMinutes(m);
    setSleepTimerEndAt(Date.now() + m * 60 * 1000);
    message.success(`定时关闭已设置：${m} 分钟`);
  }, [setSleepTimerEndAt, setSleepTimerMinutes]);

  useEffect(() => {
    if (!autoCarousel) {
      setCarouselState((prev) => ({ ...prev, visible: false }));
    }
  }, [autoCarousel]);

  useEffect(() => {
    if (!blurWords) {
      setRevealedIds(new Set());
    }
  }, [blurWords, setRevealedIds]);

  useEffect(() => {
    if (!carouselState.visible || carouselState.urls.length <= 1) return () => {};
    const timer = setInterval(() => {
      setCarouselState((prev) => ({
        ...prev,
        index: prev.urls.length ? (prev.index + 1) % prev.urls.length : 0,
      }));
    }, CAROUSEL_INTERVAL);
    return () => clearInterval(timer);
  }, [carouselState.visible, carouselState.urls]);

  useEffect(() => {
    const handleMove = (e) => {
      if (!draggingRef.current) return;
      setCarouselPos({
        x: e.clientX - dragOffsetRef.current.x,
        y: e.clientY - dragOffsetRef.current.y,
      });
    };
    const handleUp = () => {
      draggingRef.current = false;
    };
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleUp);
    return () => {
      window.removeEventListener('mousemove', handleMove);
      window.removeEventListener('mouseup', handleUp);
    };
  }, []);

  useEffect(() => {
    if (!previewSrc) return () => {};
    const handleKey = (e) => {
      if (!previewList.length) return;
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        setPreviewIndex((idx) => (idx + 1) % previewList.length);
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        setPreviewIndex((idx) => (idx - 1 + previewList.length) % previewList.length);
      }
    };
    window.addEventListener('keydown', handleKey);
    return () => {
      window.removeEventListener('keydown', handleKey);
    };
  }, [previewSrc, previewList]);

  const openImagesForWord = useCallback((word) => {
    if (showCloze || !autoCarousel) return;
    const key = word.toLowerCase();
    const entry = imageMapRef.current[key];
    setCarouselState((prev) => {
      const sameWord = prev.word?.toLowerCase() === key;
      const hasUrls = entry?.urls?.length;
      if (sameWord && prev.visible && hasUrls) {
        return prev;
      }
      return {
        word,
        urls: entry?.urls || [],
        index: 0,
        visible: true,
        loading: !entry?.urls?.length,
      };
    });
    if (!entry?.urls?.length) {
      fetchImages(word);
    }
  }, [autoCarousel, fetchImages, showCloze]);

  const handleChunkPlay = useCallback(async (targetIndex, options = {}) => {
    if (!segments.length) return;
    const startIdx = segments.findIndex((seg) => seg.index === targetIndex);
    if (startIdx === -1) return;
    const {
      continuous = false,
      repeat,
      gapMs = 0,
      betweenChunksMs = 0,
      triggerPreview = true,
      triggerReveal = true,
      forceShadowing = false,
    } = options;
    cancelCurrentPlayback(true);
    const controller = { cancelled: false, paused: false };
    playbackRef.current = controller;
    if (continuous) {
      setIsPlaying(true);
      setIsPaused(false);
    }
    let idx = startIdx;
    let lastPlayedIndex = null;
    const shouldLoop = continuous;
    while (idx < segments.length || shouldLoop) {
      if (controller.cancelled) break;
      if (controller.paused) break;
      if (idx >= segments.length) {
        // Infinite loop: after reaching the end, continue from the beginning.
        idx = 0;
        continue;
      }
      const chunk = segments[idx];
      if (!chunk) break;
      if (chunk.type === 'punct') {
        idx += 1;
        continue;
      }
      const prefetchUpcomingAudio = () => {
        const speakable = segments.filter((seg) => seg.type !== 'punct');
        const currentPos = speakable.findIndex((seg) => seg.index === chunk.index);
        if (currentPos === -1) return;
        const nextTargets = speakable.slice(currentPos + 1, currentPos + 3);
        nextTargets.forEach((seg) => {
          const textValue = (seg.value || '').trim();
          if (!textValue) return;
          const cacheKey = buildAudioCacheKey(textValue, azureVoice, 1.0);
          if (audioCache.current?.[cacheKey]) return;
          ensureAudio(textValue, azureVoice).catch(() => {});
        });
      };
      flushSync(() => {
        setActiveIndex(chunk.index);
      });
      lastPlayedIndex = chunk.index;
      const textValue = (chunk.value || '').trim();
      const playable = textValue && chunk.type !== 'punct';
      if (playable) {
        // Ensure the active highlight paints before starting the next audio.
        if (!continuous && typeof window !== 'undefined') {
          await new Promise((resolve) => window.requestAnimationFrame(resolve));
        }
        prefetchUpcomingAudio();
        const playTimes = typeof repeat === 'number'
          ? repeat
          : continuous
            ? 1
            : chunk.type === 'fr'
              ? Math.max(1, clampedFrCount)
              : chunk.type === 'cn'
                ? Math.max(1, clampedCnCount)
                : 1;
        const voice = azureVoice;
        try {
          const shadowingActive = forceShadowing || shadowingEnabled;
          if (shadowingActive && chunk.type === 'fr') {
            const playShadowing = async (repIndex, seqIndex) => {
              if (controller.cancelled || controller.paused) return;
              const rate = normalizedShadowingSequence[seqIndex];
              await playWord(textValue, 1, voice, {
                rate,
                onSpeedChange: setCurrentPlayingSpeed,
                shouldAbort: () => controller.cancelled || controller.paused,
              });
              if (controller.cancelled || controller.paused) return;
              const isLastPlay = repIndex === playTimes - 1
                && seqIndex === normalizedShadowingSequence.length - 1;
              if (!isLastPlay && gapMs > 0) {
                const ok = await waitForPlaybackGap(gapMs, controller);
                if (!ok) return;
              }
              if (seqIndex + 1 < normalizedShadowingSequence.length) {
                await playShadowing(repIndex, seqIndex + 1);
                return;
              }
              if (repIndex + 1 < playTimes) {
                await playShadowing(repIndex + 1, 0);
              }
            };
            if (normalizedShadowingSequence.length > 0 && playTimes > 0) {
              await playShadowing(0, 0);
            }
          } else {
            setCurrentPlayingSpeed(null);
            await playWord(textValue, playTimes, voice, {
              gapMs,
              shouldAbort: () => controller.cancelled || controller.paused,
            });
          }
        } catch {
          controller.cancelled = true;
          break;
        } finally {
          setCurrentPlayingSpeed(null);
        }
        if (controller.paused || controller.cancelled) break;
        if (!continuous && triggerPreview && !showCloze && chunk.type === 'fr') {
          openImagesForWord(textValue);
        }
        if (!continuous && triggerReveal && blurWords && !showCloze && chunk.type === 'fr') {
          setRevealedIds((prev) => {
            const next = new Set(prev);
            if (next.has(chunk.id)) {
              next.delete(chunk.id);
            } else {
              next.add(chunk.id);
            }
            return next;
          });
        }
        if (!continuous && betweenChunksMs > 0) {
          const ok = await waitForPlaybackGap(betweenChunksMs, controller);
          if (!ok || controller.paused || controller.cancelled) break;
        }
        if (continuous && betweenChunksMs > 0) {
          const ok = await waitForPlaybackGap(betweenChunksMs, controller);
          if (!ok || controller.paused || controller.cancelled) break;
        }
      }
      if (!continuous) break;
      idx += 1;
    }
    if (controller.paused) return;
    if (controller.cancelled) {
      if (!continuous && !controller.skipRestore && typeof lastPlayedIndex === 'number') {
        setActiveIndex(lastPlayedIndex);
      }
      return;
    }
    if (continuous) {
      setIsPlaying(false);
      setIsPaused(false);
      setActiveIndex(-1);
    } else if (typeof lastPlayedIndex === 'number') {
      setActiveIndex(lastPlayedIndex);
    }
  }, [
    segments,
    cancelCurrentPlayback,
    clampedFrCount,
    clampedCnCount,
    azureVoice,
    buildAudioCacheKey,
    playWord,
    ensureAudio,
    showCloze,
    openImagesForWord,
    blurWords,
    setRevealedIds,
    setCurrentPlayingSpeed,
    shadowingEnabled,
    normalizedShadowingSequence,
    waitForPlaybackGap,
  ]);

  const activateAndPlay = useCallback((index, options = {}) => {
    playRequestTokenRef.current += 1;
    const token = playRequestTokenRef.current;
    // Stop current audio immediately so the UI feels responsive.
    setLoadingWord('');
    setCurrentPlayingSpeed(null);
    cancelCurrentPlayback(true);
    flushSync(() => {
      setActiveIndex(index);
    });
    if (typeof window === 'undefined') {
      handleChunkPlay(index, options);
      return;
    }
    // Delay playback until after paint so the highlight always appears first.
    window.requestAnimationFrame(() => {
      window.requestAnimationFrame(() => {
        if (playRequestTokenRef.current !== token) return;
        handleChunkPlay(index, options);
      });
    });
  }, [cancelCurrentPlayback, handleChunkPlay, setCurrentPlayingSpeed]);

  const getLoopStartPos = useCallback((list) => {
    if (!list.length) return 0;
    const exact = list.findIndex((seg) => seg.index === activeIndex);
    if (exact >= 0) return exact;
    const next = list.findIndex((seg) => seg.index > activeIndex);
    return next >= 0 ? next : 0;
  }, [activeIndex]);
  const getLoopStartPosFor = useCallback((list, startIndex) => {
    if (!list.length) return 0;
    const exact = list.findIndex((seg) => seg.index === startIndex);
    if (exact >= 0) return exact;
    const next = list.findIndex((seg) => seg.index > startIndex);
    return next >= 0 ? next : 0;
  }, []);

  const startSentenceLoop = useCallback((startIndex, options = {}) => {
    const { forceShadowing = false } = options;
    if (!segments.length) return;
    sentenceLoopTokenRef.current += 1;
    const token = sentenceLoopTokenRef.current;
    setSentenceLooping(true);
    setForeignLooping(false);
    (async () => {
      const speakable = segments
        .filter((seg) => seg.type !== 'punct' && (seg.value || '').trim())
        .sort((a, b) => a.index - b.index);
      if (!speakable.length) return;
      const startPos = typeof startIndex === 'number'
        ? getLoopStartPosFor(speakable, startIndex)
        : getLoopStartPos(speakable);
      const intervalMs = Math.round(clampedIntervalSeconds * 1000);
      const shadowingActive = forceShadowing || shadowingEnabled;
      let pos = startPos;
      while (sentenceLoopTokenRef.current === token) {
        const seg = speakable[pos];
        const repeatTimes = seg.type === 'cn'
          ? Math.max(1, clampedCnCount)
          : Math.max(1, clampedFrCount);
        await handleChunkPlay(seg.index, {
          repeat: repeatTimes,
          gapMs: intervalMs,
          triggerPreview: false,
          triggerReveal: false,
          betweenChunksMs: shadowingActive ? intervalMs : 0,
          forceShadowing,
        });
        if (sentenceLoopTokenRef.current !== token) return;
        if (!shadowingActive && intervalMs > 0) {
          let remaining = intervalMs;
          while (remaining > 0) {
            if (sentenceLoopTokenRef.current !== token) return;
            const step = Math.min(250, remaining);
            await new Promise((resolve) => setTimeout(resolve, step));
            remaining -= step;
          }
        }
        pos = (pos + 1) % speakable.length;
      }
    })()
      .finally(() => {
        if (sentenceLoopTokenRef.current === token) {
          setSentenceLooping(false);
        }
      });
  }, [
    clampedCnCount,
    clampedFrCount,
    clampedIntervalSeconds,
    getLoopStartPos,
    getLoopStartPosFor,
    handleChunkPlay,
    shadowingEnabled,
    segments,
  ]);

  const startForeignLoop = useCallback((startIndex, options = {}) => {
    const { forceShadowing = false } = options;
    if (!segments.length) return;
    sentenceLoopTokenRef.current += 1;
    const token = sentenceLoopTokenRef.current;
    setForeignLooping(true);
    setSentenceLooping(false);
    (async () => {
      const foreignOnly = segments
        .filter((seg) => seg.type === 'fr' && seg.type !== 'punct' && (seg.value || '').trim())
        .sort((a, b) => a.index - b.index);
      if (!foreignOnly.length) return;
      const startPos = typeof startIndex === 'number'
        ? getLoopStartPosFor(foreignOnly, startIndex)
        : getLoopStartPos(foreignOnly);
      const intervalMs = Math.round(clampedIntervalSeconds * 1000);
      const shadowingActive = forceShadowing || shadowingEnabled;
      let pos = startPos;
      while (sentenceLoopTokenRef.current === token) {
        const seg = foreignOnly[pos];
        const repeatTimes = Math.max(1, clampedFrCount);
        await handleChunkPlay(seg.index, {
          repeat: repeatTimes,
          gapMs: intervalMs,
          triggerPreview: false,
          triggerReveal: false,
          betweenChunksMs: shadowingActive ? intervalMs : 0,
          forceShadowing,
        });
        if (sentenceLoopTokenRef.current !== token) return;
        if (!shadowingActive && intervalMs > 0) {
          let remaining = intervalMs;
          while (remaining > 0) {
            if (sentenceLoopTokenRef.current !== token) return;
            const step = Math.min(250, remaining);
            await new Promise((resolve) => setTimeout(resolve, step));
            remaining -= step;
          }
        }
        pos = (pos + 1) % foreignOnly.length;
      }
    })()
      .finally(() => {
        if (sentenceLoopTokenRef.current === token) {
          setForeignLooping(false);
        }
      });
  }, [
    clampedFrCount,
    clampedIntervalSeconds,
    getLoopStartPos,
    getLoopStartPosFor,
    handleChunkPlay,
    shadowingEnabled,
    segments,
  ]);

  const startSingleSentenceLoop = useCallback((startIndex, options = {}) => {
    const { forceShadowing = false } = options;
    if (!segments.length) return;
    const speakable = segments
      .filter((seg) => seg.type !== 'punct' && (seg.value || '').trim())
      .sort((a, b) => a.index - b.index);
    if (!speakable.length) return;
    const current = typeof startIndex === 'number'
      ? speakable.find((seg) => seg.index === startIndex)
      : speakable.find((seg) => seg.index === activeIndex) || speakable[0];
    if (!current) return;
    singleSentenceLoopTokenRef.current += 1;
    const token = singleSentenceLoopTokenRef.current;
    setSingleSentenceLooping(true);
    const intervalMs = Math.round(clampedIntervalSeconds * 1000);
    (async () => {
      while (singleSentenceLoopTokenRef.current === token) {
        await handleChunkPlay(current.index, {
          repeat: 1,
          gapMs: intervalMs,
          betweenChunksMs: 0,
          triggerPreview: false,
          triggerReveal: false,
          forceShadowing,
        });
        if (singleSentenceLoopTokenRef.current !== token) return;
        if (intervalMs > 0) {
          let remaining = intervalMs;
          while (remaining > 0) {
            if (singleSentenceLoopTokenRef.current !== token) return;
            const step = Math.min(250, remaining);
            await new Promise((resolve) => setTimeout(resolve, step));
            remaining -= step;
          }
        }
      }
    })()
      .finally(() => {
        if (singleSentenceLoopTokenRef.current === token) {
          setSingleSentenceLooping(false);
        }
      });
  }, [
    activeIndex,
    clampedIntervalSeconds,
    handleChunkPlay,
    segments,
  ]);

  const toggleSentenceLoop = useCallback(() => {
    if (!segments.length) return;
    if (sentenceLooping) {
      sentenceLoopTokenRef.current += 1;
      setSentenceLooping(false);
      setForeignLooping(false);
      setSingleSentenceLooping(false);
      cancelCurrentPlayback(true);
      return;
    }
    if (singleSentenceLooping) {
      singleSentenceLoopTokenRef.current += 1;
      setSingleSentenceLooping(false);
    }
    startSentenceLoop();
  }, [
    cancelCurrentPlayback,
    segments,
    startSentenceLoop,
    sentenceLooping,
    singleSentenceLoopTokenRef,
    singleSentenceLooping,
    setSingleSentenceLooping,
  ]);

  const toggleForeignLoop = useCallback(() => {
    if (!segments.length) return;
    if (foreignLooping) {
      sentenceLoopTokenRef.current += 1;
      setForeignLooping(false);
      setSentenceLooping(false);
      setSingleSentenceLooping(false);
      cancelCurrentPlayback(true);
      return;
    }
    if (singleSentenceLooping) {
      singleSentenceLoopTokenRef.current += 1;
      setSingleSentenceLooping(false);
    }
    startForeignLoop();
  }, [
    cancelCurrentPlayback,
    foreignLooping,
    segments,
    startForeignLoop,
    singleSentenceLoopTokenRef,
    singleSentenceLooping,
    setSingleSentenceLooping,
  ]);

  const toggleSingleSentenceLoop = useCallback(() => {
    if (!segments.length) return;
    if (singleSentenceLooping) {
      singleSentenceLoopTokenRef.current += 1;
      setSingleSentenceLooping(false);
      cancelCurrentPlayback(true);
      return;
    }
    sentenceLoopTokenRef.current += 1;
    setSentenceLooping(false);
    setForeignLooping(false);
    cancelCurrentPlayback(true);
    startSingleSentenceLoop(undefined, { forceShadowing: shadowingEnabled });
  }, [
    cancelCurrentPlayback,
    segments,
    shadowingEnabled,
    singleSentenceLooping,
    startSingleSentenceLoop,
  ]);

  const handleShadowingAction = useCallback(() => {
    const current = segments.find((seg) => seg.index === activeIndex);
    if (!current || current.type !== 'fr' || current.type === 'punct') return;
    if (shadowingEnabled) {
      singleSentenceLoopTokenRef.current += 1;
      setSingleSentenceLooping(false);
      sentenceLoopTokenRef.current += 1;
      setSentenceLooping(false);
      setForeignLooping(false);
      setShadowingEnabled(false);
      cancelCurrentPlayback(true);
      return;
    }
    setShadowingEnabled(true);
    if (singleSentenceLooping) {
      startSingleSentenceLoop(current.index, { forceShadowing: true });
      return;
    }
    if (sentenceLooping) {
      startSentenceLoop(current.index, { forceShadowing: true });
      return;
    }
    if (foreignLooping) {
      startForeignLoop(current.index, { forceShadowing: true });
      return;
    }
    activateAndPlay(current.index, { triggerPreview: true, triggerReveal: true, forceShadowing: true });
  }, [
    activeIndex,
    activateAndPlay,
    cancelCurrentPlayback,
    foreignLooping,
    segments,
    sentenceLoopTokenRef,
    sentenceLooping,
    singleSentenceLoopTokenRef,
    singleSentenceLooping,
    setForeignLooping,
    setSentenceLooping,
    setSingleSentenceLooping,
    setShadowingEnabled,
    shadowingEnabled,
    startForeignLoop,
    startSentenceLoop,
    startSingleSentenceLoop,
  ]);

  const resolveMoveScope = useCallback((scope) => {
    if (scope === 'foreign') {
      return showCloze ? 'blank' : 'fr';
    }
    if (foreignLooping && scope === 'all') {
      return showCloze ? 'blank' : 'fr';
    }
    return scope;
  }, [foreignLooping, showCloze]);

  const handleChunkActivate = useCallback((segment) => {
    if (!segment) return;
    if (sentenceLooping || foreignLooping || singleSentenceLooping) {
      sentenceLoopTokenRef.current += 1;
      singleSentenceLoopTokenRef.current += 1;
      if (playbackRef.current) {
        playbackRef.current.skipRestore = true;
      }
      cancelCurrentPlayback(true);
      flushSync(() => {
        setActiveIndex(segment.index);
      });
      if (singleSentenceLooping) {
        startSingleSentenceLoop(segment.index, { forceShadowing: shadowingEnabled });
      } else if (sentenceLooping) {
        startSentenceLoop(segment.index, { forceShadowing: shadowingEnabled });
      } else {
        startForeignLoop(segment.index, { forceShadowing: shadowingEnabled });
      }
      return;
    }
    activateAndPlay(segment.index, { triggerPreview: true, triggerReveal: true });
  }, [
    activateAndPlay,
    cancelCurrentPlayback,
    foreignLooping,
    sentenceLooping,
    singleSentenceLooping,
    shadowingEnabled,
    startForeignLoop,
    startSentenceLoop,
    startSingleSentenceLoop,
    singleSentenceLoopTokenRef,
  ]);

  const moveActiveWithin = useCallback((list, delta) => {
    if (!list.length) return null;
    const getKey = (value) => (Number.isFinite(Number(value)) ? Number(value) : value);
    const order = list.map((seg) => getKey(seg.index));
    const activeKey = getKey(activeIndex);
    const currentIdx = order.findIndex((idx) => idx === activeKey);
    if (currentIdx === -1) {
      const fallbackIdx = delta > 0 ? 0 : order.length - 1;
      return list.find((seg) => getKey(seg.index) === order[fallbackIdx]) || null;
    }
    const nextIdx = currentIdx + delta;
    const wrappedIdx = (nextIdx % order.length + order.length) % order.length;
    return list.find((seg) => getKey(seg.index) === order[wrappedIdx]) || null;
  }, [activeIndex]);

  const moveActive = useCallback((delta, options = {}) => {
    const { scope = 'all' } = options;
    if (!segments.length) return;
    const wasSentenceLooping = sentenceLooping;
    const wasForeignLooping = foreignLooping;
    const wasSingleSentenceLooping = singleSentenceLooping;
    let target = null;
    if (scope === 'blank') {
      const blanksOnly = segments.filter((seg) => seg.role === 'blank');
      target = moveActiveWithin(blanksOnly, delta);
    }
    if (scope === 'fr') {
      const frOnly = segments
        .filter((seg) => seg.type === 'fr' && seg.type !== 'punct')
        .sort((a, b) => a.index - b.index);
      target = moveActiveWithin(frOnly, delta);
    }
    if (!target) {
      const sorted = segments
        .filter((seg) => seg.type !== 'punct')
        .sort((a, b) => a.index - b.index);
      target = moveActiveWithin(sorted, delta);
    }
    if (target) {
      if (wasSentenceLooping || wasForeignLooping || wasSingleSentenceLooping) {
        sentenceLoopTokenRef.current += 1;
        singleSentenceLoopTokenRef.current += 1;
        if (playbackRef.current) {
          playbackRef.current.skipRestore = true;
        }
        cancelCurrentPlayback(true);
        flushSync(() => {
          setActiveIndex(target.index);
        });
        if (wasSingleSentenceLooping) {
          startSingleSentenceLoop(target.index, { forceShadowing: shadowingEnabled });
        } else if (wasSentenceLooping) {
          startSentenceLoop(target.index, { forceShadowing: shadowingEnabled });
        } else {
          startForeignLoop(target.index, { forceShadowing: shadowingEnabled });
        }
        return;
      }
      activateAndPlay(target.index, { triggerPreview: true, triggerReveal: false });
    }
  }, [
    activateAndPlay,
    cancelCurrentPlayback,
    foreignLooping,
    moveActiveWithin,
    shadowingEnabled,
    segments,
    sentenceLooping,
    singleSentenceLooping,
    startForeignLoop,
    startSentenceLoop,
    startSingleSentenceLoop,
  ]);

  const registerChunkRef = useCallback((index, el) => {
    if (el) {
      chunkRefs.current[index] = el;
    } else {
      delete chunkRefs.current[index];
    }
  }, []);

  useEffect(() => {
    if (!isPlaying && !isPaused) return;
    if (typeof activeIndex !== 'number' || activeIndex < 0) return;
    const container = mainScrollRef.current;
    const target = chunkRefs.current[activeIndex];
    if (!container || !target) return;
    const containerRect = container.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();
    const currentScroll = container.scrollTop;
    const offset = targetRect.top - containerRect.top;
    const desired = currentScroll + offset - (containerRect.height / 2) + (targetRect.height / 2);
    container.scrollTo({
      top: Math.max(0, desired),
      behavior: 'smooth',
    });
  }, [activeIndex, isPaused, isPlaying]);
  const togglePausePlayback = useCallback(() => {
    if (!isPlaying || !playbackRef.current) return;
    const controller = playbackRef.current;
    if (!isPaused) {
      controller.paused = true;
      controller.resumeIndex = activeIndex;
      stopAudio();
      setIsPaused(true);
      return;
    }
    const resumeIndex = (typeof activeIndex === 'number' && activeIndex >= 0)
      ? activeIndex
      : controller.resumeIndex ?? segments[0]?.index;
    if (typeof resumeIndex !== 'number') return;
    setIsPaused(false);
    handleChunkPlay(resumeIndex, { continuous: true, triggerPreview: false, triggerReveal: false });
  }, [activeIndex, handleChunkPlay, isPaused, isPlaying, segments, stopAudio]);

  const onExtract = useCallback(() => {
    const count = extractWords();
    if (!count) {
      message.warning('未找到可挖空的法语候选词，请检查文本');
      return;
    }
    // message.success(`已提取 ${count} 个候选词并完成挖空`);
  }, [extractWords]);

  const onReset = useCallback(() => {
    resetCloze();
    const first = blanks[0];
    if (first) {
      setActiveIndex(first.index);
      handleChunkPlay(first.index, { repeat: Math.max(1, clampedFrCount), triggerPreview: true, triggerReveal: false });
    }
    // message.info('已恢复为原文');
  }, [blanks, clampedFrCount, handleChunkPlay, resetCloze, setActiveIndex]);

  const handleToggleMode = useCallback((checked) => {
    if (checked) {
      onExtract();
    } else {
      onReset();
    }
  }, [onExtract, onReset]);

  const onPlay = async (word) => {
    setLoadingWord(word);
    try {
      if (shadowingEnabled && /[A-Za-z\u00C0-\u024F]/.test(word || '')) {
        const playShadowingWord = async (seqIndex) => {
          if (seqIndex >= normalizedShadowingSequence.length) return;
          const rate = normalizedShadowingSequence[seqIndex];
          await playWord(word, 1, azureVoice, {
            rate,
            onSpeedChange: setCurrentPlayingSpeed,
          });
          await playShadowingWord(seqIndex + 1);
        };
        await playShadowingWord(0);
      } else {
        setCurrentPlayingSpeed(null);
        await playWord(word);
      }
    } catch {
      // handled inside hook
    } finally {
      setLoadingWord('');
      setCurrentPlayingSpeed(null);
    }
  };

  const handleChange = (id, val) => {
    setAnswer(id, val);
  };

  const validateBlank = useCallback((item, rawInput) => {
    const inputVal = String(rawInput ?? answers[item.id] ?? '').trim();
    const sensitivity = accentCheck ? 'accent' : 'base';
    const correct = inputVal.localeCompare(item.value, undefined, { sensitivity, usage: 'search' }) === 0;
    if (correct && !accentCheck && inputVal !== item.value) {
      setAnswer(item.id, item.value);
    }
    setStatus(item.id, correct ? 'correct' : 'wrong');
    return correct;
  }, [accentCheck, answers, setAnswer, setStatus]);

  const handleEnter = (item, rawInput) => {
    const correct = validateBlank(item, rawInput);
    if (correct) {
      const idx = blanks.findIndex((seg) => seg.id === item.id);
      const next = blanks[idx + 1];
      if (next) {
        setTimeout(() => inputRefs.current[next.id]?.focus(), 10);
      }
    } else {
      setTimeout(() => inputRefs.current[item.id]?.focus(), 10);
    }
  };

  const handleKeyDown = (e, item) => {
    const key = e.key;
    const isEnter = key === 'Enter' || e.code === 'Enter' || e.keyCode === 13;
    if (isEnter) {
      e.preventDefault();
      handleEnter(item, e.target?.value);
    } else if (e.key === 'Tab') {
      e.preventDefault();
      const idx = blanks.findIndex((seg) => seg.id === item.id);
      const next = blanks[idx + (e.shiftKey ? -1 : 1)];
      if (next) {
        setTimeout(() => inputRefs.current[next.id]?.focus(), 10);
      }
    }
  };

  const onKeyNavigate = useCallback((e) => {
    if (showCloze || !segments.length) return;
    const target = e.target;
    const tag = target?.tagName?.toLowerCase?.();
    if (tag === 'input' || tag === 'textarea' || target?.isContentEditable) return;
    if (['ArrowRight'].includes(e.key)) {
      e.preventDefault();
      moveActive(1);
    } else if (['ArrowLeft'].includes(e.key)) {
      e.preventDefault();
      moveActive(-1);
    } else if (['ArrowUp'].includes(e.key)) {
      e.preventDefault();
      moveActive(-1, { scope: 'fr' });
    } else if (['ArrowDown'].includes(e.key)) {
      e.preventDefault();
      moveActive(1, { scope: 'fr' });
    } else if (e.key === 'Tab') {
      e.preventDefault();
      moveActive(e.shiftKey ? -1 : 1, { scope: 'fr' });
    } else if (e.key === 'Enter') {
      e.preventDefault();
      const current = segments.find((seg) => seg.index === activeIndex) || segments[0];
      if (current) {
        activateAndPlay(current.index, { triggerPreview: true, triggerReveal: false });
      }
    }
  }, [activeIndex, activateAndPlay, moveActive, segments, showCloze]);

  useEffect(() => {
    if (typeof window === 'undefined' || !isMobile) return undefined;
    window.addEventListener('keydown', onKeyNavigate);
    return () => window.removeEventListener('keydown', onKeyNavigate);
  }, [isMobile, onKeyNavigate]);

  const prefetchAudio = async () => {
    const blankWords = segments
      .filter((seg) => seg.role === 'blank' && (seg.value || '').trim())
      .map((seg) => seg.value);
    const fallbackWords = segments
      .filter((seg) => seg.type === 'fr' && seg.type !== 'punct' && (seg.value || '').trim())
      .map((seg) => seg.value);
    const uniqueWords = Array.from(new Set((blankWords.length ? blankWords : fallbackWords).map((w) => String(w).trim())));
    if (!uniqueWords.length) {
      message.info('暂无可缓存的外语语块');
      return;
    }
    const rates = shadowingEnabled ? normalizedShadowingSequence : [1.0];
    const pending = [];
    uniqueWords.forEach((word) => {
      rates.forEach((rate) => {
        const key = buildAudioCacheKey(word, azureVoice, rate);
        if (!audioCache.current?.[key]) {
          pending.push({ word, rate });
        }
      });
    });
    if (!pending.length) {
      message.info('外语音频已全部缓存');
      return;
    }
    setPrefetching(true);
    setPrefetchProgress({ done: 0, total: pending.length });
    try {
      for (let i = 0; i < pending.length; i += 1) {
        const { word, rate } = pending[i];
        await ensureAudio(word, azureVoice, rate);
        setPrefetchProgress({ done: i + 1, total: pending.length });
      }
      message.success('音频已缓存完成');
    } catch (error) {
      const detail = error.response?.data?.message || error.message;
      message.error(`缓存失败：${detail}`);
    } finally {
      setPrefetching(false);
    }
  };

  const prefetchChinese = async () => {
    const segs = segments
      .filter((seg) => seg.type === 'cn')
      .map((seg) => (seg.value || '').trim())
      .filter(Boolean);
    const unique = Array.from(new Set(segs));
    const pending = unique.filter((t) => !audioCache.current?.[buildAudioCacheKey(t, azureVoice, 1.0)]);
    if (!pending.length) {
      message.info('中文音频已全部缓存');
      message.info('暂无可缓存的中文片段');
      return;
    }
    setPrefetchingCn(true);
    setPrefetchProgressCn({ done: 0, total: pending.length });
    try {
      for (let i = 0; i < pending.length; i += 1) {
        const text = pending[i];
        await ensureAudio(text, azureVoice);
        setPrefetchProgressCn({ done: i + 1, total: pending.length });
      }
      message.success('中文片段已缓存完成');
    } catch (error) {
      const detail = error.response?.data?.message || error.message;
      message.error(`中文缓存失败：${detail}`);
    } finally {
      setPrefetchingCn(false);
    }
  };

  const readFullText = useCallback(() => {
    if (!segments.length) return;
    // Stop sentence/foreign loops when switching to full-text playback.
    sentenceLoopTokenRef.current += 1;
    setSentenceLooping(false);
    setForeignLooping(false);
    const startIndex = typeof activeIndex === 'number' && activeIndex >= 0
      ? activeIndex
      : segments[0]?.index;
    if (typeof startIndex !== 'number') return;
    handleChunkPlay(startIndex, {
      continuous: true,
      betweenChunksMs: Math.round(clampedIntervalSeconds * 1000),
      triggerPreview: false,
      triggerReveal: false,
    });
  }, [activeIndex, clampedIntervalSeconds, handleChunkPlay, segments]);

  const startCreate = () => {
    setCreating(true);
    setActiveArticle(null);
    setNewContent('');
    setCarouselState((prev) => ({ ...prev, visible: false }));
    setPendingArticleId(null);
    updateUrl(null);
  };

  const saveCreate = async () => {
    const trimmed = newContent.trim();
    if (!trimmed) {
      setContentError('请填写内容');
      return;
    }
    if (trimmed.length > 20000) {
      setContentError('不能超过20000个字符');
      return;
    }
    setContentError('');
    const computedTitle = (trimmed.split(/\s+/)[0] || '未命名').slice(0, 20);
    const created = await createArticle(computedTitle, newContent);
    if (created) {
      setActiveArticle(created);
      setCreating(false);
      setNewContent('');
      setContentError('');
    }
  };

  const handleDeleteArticle = async (id) => {
    await deleteArticle(id);
    const remaining = articles.filter((a) => a.id !== id);
    if (remaining.length) {
      setActiveArticle(remaining[0]);
      setCreating(false);
      updateUrl(remaining[0].id);
    } else {
      setActiveArticle(null);
      setCreating(true);
      updateUrl(null);
    }
  };

  const nextSlide = () => {
    setCarouselState((prev) => {
      if (!prev.urls.length) return prev;
      return { ...prev, index: (prev.index + 1) % prev.urls.length };
    });
  };

  const prevSlide = () => {
    setCarouselState((prev) => {
      if (!prev.urls.length) return prev;
      return { ...prev, index: (prev.index - 1 + prev.urls.length) % prev.urls.length };
    });
  };

  const handleCarouselWheel = (e) => {
    if (!carouselState.visible) return;
    const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
    if (delta > 0) {
      nextSlide();
    } else if (delta < 0) {
      prevSlide();
    }
  };

  const prefetchImages = async () => {
    const words = Array.from(new Set(selectedWords));
    await prefetchImagesAll(words);
  };

  const handleCarouselDragStart = (e) => {
    if (e.target.closest('button') || e.target.tagName === 'IMG') return;
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffsetRef.current = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    draggingRef.current = true;
  };

  useEffect(() => {
    if (!autoCarousel) {
      setCarouselPos(computeDefaultCarouselPos());
    }
  }, [autoCarousel]);

  const saveConfig = async () => {
    setConfigLoading(true);
    try {
      await api.put('/api/user/config', {
        azure_key: azureKey,
        azure_region: azureRegion,
        azure_voice: azureVoice,
      });
      message.success('配置已保存');
      setConfigOpen(false);
    } catch {
      message.error('保存失败');
    } finally {
      setConfigLoading(false);
    }
  };

  const handleArticleSelect = (item) => {
    setCreating(false);
    setActiveArticle(item);
    updateUrl(item.id);
    if (isMobile) {
      setMobileSidebarOpen(false);
    }
  };

  return (
    <>
      {isMobile && (
        <div
          className={`pull-refresh-indicator ${pullStatus !== 'idle' ? 'visible' : ''}`}
          style={{
            transform: `translate(-50%, ${indicatorY}px) scale(${indicatorScale})`,
          }}
        >
          {/* <div
            className={`pull-refresh-icon ${pullStatus}`}
            style={pullStatus === 'refreshing' ? undefined : { transform: `rotate(${pullProgress * 240}deg)` }}
          /> */}
          <span className="pull-refresh-text">{pullLabel}</span>
          <div className="pull-refresh-bar">
            <div className="pull-refresh-bar-fill" style={{ '--pull-progress': pullProgress }} />
          </div>
        </div>
      )}
      <ImageCarousel
        visible={autoCarousel && carouselState.visible}
        state={carouselState}
        position={carouselPos}
        onClose={() => setCarouselState((prev) => ({ ...prev, visible: false }))}
        onNext={nextSlide}
        onPrev={prevSlide}
        onRefresh={(word) => fetchImages(word, true)}
        onWheel={handleCarouselWheel}
        onPreview={(urls, idx) => {
          setPreviewList(urls);
          setPreviewIndex(idx);
          setPreviewSrc(urls[idx]);
        }}
        innerRef={carouselRef}
        onDragStart={handleCarouselDragStart}
      />
      <Modal
        title="学习统计"
        open={studyStatsOpen}
        onCancel={() => setStudyStatsOpen(false)}
        footer={null}
        destroyOnHidden
      >
        <div className="study-stats-grid">
          <div className="study-stats-card">
            <div className="study-stats-label">今日学习时长</div>
            <div className="study-stats-value">{formatDuration(studyStats.todayMs)}</div>
          </div>
          <div className="study-stats-card">
            <div className="study-stats-label">总学习时长</div>
            <div className="study-stats-value">{formatDuration(studyStats.totalMs)}</div>
          </div>
        </div>
        {studyStatsLoading && <div style={{ marginTop: 12 }}><Spin /></div>}
      </Modal>

      <div className="app-layout">
        {!isMobile && (
          <aside
            className={`app-sidebar ${sidebarCollapsed ? 'collapsed' : ''}`}
            style={{ width: sidebarCollapsed ? 60 : 280, minWidth: sidebarCollapsed ? 60 : 240 }}
          >
            <ArticleList
              items={articles}
              loading={articlesLoading}
              saving={articlesSaving}
              onCreate={createArticle}
              onCreateStart={startCreate}
              onUpdate={updateArticle}
              onDelete={handleDeleteArticle}
              onSelect={handleArticleSelect}
              activeId={activeArticle?.id}
              collapsed={sidebarCollapsed}
              onToggleCollapse={() => setSidebarCollapsed((v) => !v)}
              userEmail={user?.email || ''}
              themeMode={themeMode}
              onToggleTheme={setThemeMode}
              onOpenConfig={() => {
                setConfigOpen(true);
                loadConfig();
              }}
              onOpenShadowingConfig={() => setShadowingConfigOpen(true)}
              onOpenStudyStats={() => setStudyStatsOpen(true)}
              backgroundPlaybackEnabled={backgroundPlaybackEnabled}
              onToggleBackgroundPlayback={setBackgroundPlaybackEnabled}
              sleepTimerMinutes={sleepTimerMinutes}
              onSleepTimerMinutesChange={handleSleepTimerChange}
              onLogout={logout}
              fetchItem={fetchItem}
              onLogoClick={startCreate}
            />
          </aside>
        )}

        {isMobile && (
          <Drawer
            placement="left"
            width="84%"
            open={mobileSidebarOpen}
            maskClosable
            onClose={() => setMobileSidebarOpen(false)}
            className="mobile-sidebar-drawer"
          >
            <ArticleList
              items={articles}
              loading={articlesLoading}
              saving={articlesSaving}
              onCreate={createArticle}
              onCreateStart={() => {
                startCreate();
                setMobileSidebarOpen(false);
              }}
              onUpdate={updateArticle}
              onDelete={handleDeleteArticle}
              onSelect={handleArticleSelect}
              activeId={activeArticle?.id}
              collapsed={false}
              onToggleCollapse={() => setSidebarCollapsed((v) => !v)}
              userEmail={user?.email || ''}
              themeMode={themeMode}
              onToggleTheme={setThemeMode}
              onOpenConfig={() => {
                setConfigOpen(true);
                loadConfig();
              }}
              onOpenShadowingConfig={() => setShadowingConfigOpen(true)}
              onOpenStudyStats={() => setStudyStatsOpen(true)}
              backgroundPlaybackEnabled={backgroundPlaybackEnabled}
              onToggleBackgroundPlayback={setBackgroundPlaybackEnabled}
              sleepTimerMinutes={sleepTimerMinutes}
              onSleepTimerMinutesChange={handleSleepTimerChange}
              onLogout={logout}
              fetchItem={fetchItem}
              onLogoClick={() => {
                startCreate();
                setMobileSidebarOpen(false);
              }}
            />
          </Drawer>
        )}

        <main className="app-main">
          {isMobile && (
            <div className="mobile-top-bar">
              <Button
                type="text"
                icon={<MenuOutlined />}
                onClick={() => setMobileSidebarOpen(true)}
              />
              <div className="mobile-top-title">{activeArticle?.title || 'WordLens'}</div>
              {mobileMenuProps && (
                <Dropdown menu={mobileMenuProps} trigger={['click']} placement="bottomRight">
                  <Button type="text" icon={<MoreOutlined />} />
                </Dropdown>
              )}
            </div>
          )}

          {!creating && (
            isMobile ? (
              <div className="mobile-toolbar-shell">
                <HeroSection
                  onExtract={onExtract}
                  onReset={onReset}
                  onToggleMode={handleToggleMode}
                  showCloze={showCloze}
                  onReadAll={readFullText}
                  readingAll={isPlaying && !isPaused}
                  onTogglePause={togglePausePlayback}
                  isPlaying={isPlaying}
                  isPaused={isPaused}
                  onMoveShortcut={(delta, scope) => moveActive(delta, { scope: resolveMoveScope(scope) })}
                  autoPlayCount={autoPlayCount}
                  setAutoPlayCount={setAutoPlayCount}
                  autoPlayCountCn={autoPlayCountCn}
                  setAutoPlayCountCn={setAutoPlayCountCn}
                  autoPlayIntervalSeconds={autoPlayIntervalSeconds}
                  setAutoPlayIntervalSeconds={setAutoPlayIntervalSeconds}
                  isSentenceLooping={sentenceLooping}
                  onToggleSentenceLoop={toggleSentenceLoop}
                  isForeignLooping={foreignLooping}
                  onToggleForeignLoop={toggleForeignLoop}
                  isSingleSentenceLooping={singleSentenceLooping}
                  onToggleSingleSentenceLoop={toggleSingleSentenceLoop}
                  backgroundPlaybackEnabled={backgroundPlaybackEnabled}
                  onToggleBackgroundPlayback={setBackgroundPlaybackEnabled}
                  sleepTimerMinutes={sleepTimerMinutes}
                  onSleepTimerMinutesChange={handleSleepTimerChange}
                  shadowingEnabled={shadowingEnabled}
                  onToggleShadowing={setShadowingEnabled}
                  onShadowingAction={handleShadowingAction}
                  prefetchAudio={prefetchAudio}
                  prefetching={prefetching}
                  prefetchProgress={prefetchProgress}
                  prefetchChinese={prefetchChinese}
                  prefetchingCn={prefetchingCn}
                  prefetchProgressCn={prefetchProgressCn}
                  prefetchImages={prefetchImages}
                  imagePrefetching={imagePrefetching}
                  imagePrefetchProgress={imagePrefetchProgress}
                  autoCarousel={autoCarousel}
                  blurWords={blurWords}
                  accentCheck={accentCheck}
                  setAutoCarousel={setAutoCarousel}
                  setBlurWords={setBlurWords}
                  setAccentCheck={setAccentCheck}
                  setThemeMode={setThemeMode}
                  isMobile
                  onOpenConfig={() => {
                    setConfigOpen(true);
                    loadConfig();
                  }}
                  onOpenShadowingConfig={() => setShadowingConfigOpen(true)}
                  onOpenStudyStats={() => setStudyStatsOpen(true)}
                  onToggleTheme={() => setThemeMode(themeMode === 'dark' ? 'light' : 'dark')}
                  onLogout={logout}
                  themeMode={themeMode}
                  onMenuConfig={setMobileMenuProps}
                />
              </div>
            ) : (
              <div className="main-header">
                <div className="content-container header-container">
                  <HeroSection
                    onExtract={onExtract}
                    onReset={onReset}
                    onToggleMode={handleToggleMode}
                    showCloze={showCloze}
                    onReadAll={readFullText}
                    readingAll={isPlaying && !isPaused}
                    onTogglePause={togglePausePlayback}
                    isPlaying={isPlaying}
                    isPaused={isPaused}
                    onMoveShortcut={(delta, scope) => moveActive(delta, { scope: resolveMoveScope(scope) })}
                    autoPlayCount={autoPlayCount}
                    setAutoPlayCount={setAutoPlayCount}
                    autoPlayCountCn={autoPlayCountCn}
                    setAutoPlayCountCn={setAutoPlayCountCn}
                    autoPlayIntervalSeconds={autoPlayIntervalSeconds}
                    setAutoPlayIntervalSeconds={setAutoPlayIntervalSeconds}
                    isSentenceLooping={sentenceLooping}
                    onToggleSentenceLoop={toggleSentenceLoop}
                    isForeignLooping={foreignLooping}
                    onToggleForeignLoop={toggleForeignLoop}
                    isSingleSentenceLooping={singleSentenceLooping}
                    onToggleSingleSentenceLoop={toggleSingleSentenceLoop}
                    backgroundPlaybackEnabled={backgroundPlaybackEnabled}
                    onToggleBackgroundPlayback={setBackgroundPlaybackEnabled}
                    sleepTimerMinutes={sleepTimerMinutes}
                    onSleepTimerMinutesChange={handleSleepTimerChange}
                    shadowingEnabled={shadowingEnabled}
                    onToggleShadowing={setShadowingEnabled}
                    onShadowingAction={handleShadowingAction}
                    prefetchAudio={prefetchAudio}
                    prefetching={prefetching}
                    prefetchProgress={prefetchProgress}
                    prefetchChinese={prefetchChinese}
                    prefetchingCn={prefetchingCn}
                    prefetchProgressCn={prefetchProgressCn}
                    prefetchImages={prefetchImages}
                    imagePrefetching={imagePrefetching}
                    imagePrefetchProgress={imagePrefetchProgress}
                    autoCarousel={autoCarousel}
                    blurWords={blurWords}
                  accentCheck={accentCheck}
                  setAutoCarousel={setAutoCarousel}
                  setBlurWords={setBlurWords}
                  setAccentCheck={setAccentCheck}
                    setThemeMode={setThemeMode}
                    onOpenConfig={() => {
                      setConfigOpen(true);
                      loadConfig();
                    }}
                    onOpenShadowingConfig={() => setShadowingConfigOpen(true)}
                    onOpenStudyStats={() => setStudyStatsOpen(true)}
                    onToggleTheme={() => setThemeMode(themeMode === 'dark' ? 'light' : 'dark')}
                    onLogout={logout}
                    themeMode={themeMode}
                  />
                </div>
              </div>
            )
          )}
          <div className="main-scroll-area" ref={mainScrollRef}>
            <div className="content-container">
              {(articlesLoading || !user) && !articles.length ? (
                <div className="article-panel" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: 360 }}>
                  <Spin size="large" tip="加载中..." />
                </div>
              ) : creating || (!activeArticle && !articles.length) ? (
                <div className="article-panel">
                  <div className="new-article-shell">
                    <form
                      className="new-article-form bubble-form"
                      onSubmit={(e) => {
                        e.preventDefault();
                        saveCreate();
                      }}
                    >
                      <div className="bubble-heading typing-text">{typedIntro || '\u00a0'}</div>
                      <div className="bubble-body">
                        <textarea
                          className={`bubble-input body-input ${contentError ? 'input-error' : ''}`}
                          placeholder="输入场景文章..."
                          rows={4}
                          value={newContent}
                          onChange={(e) => {
                            setNewContent(e.target.value);
                            if (e.target.value.trim().length > 20000) {
                              setContentError('不能超过20000个字符');
                            } else {
                              setContentError('');
                            }
                          }}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                              e.preventDefault();
                              saveCreate();
                            }
                          }}
                        />
                        {contentError && <div className="input-error-text">{contentError}</div>}
                        <div className="bubble-actions">
                          <Button
                            className="bubble-send"
                            htmlType="submit"
                            type="primary"
                            shape="circle"
                            icon={<span style={{ fontWeight: 700 }}>{'>'}</span>}
                            loading={articlesSaving}
                          />
                        </div>
                      </div>
                    </form>
                  </div>
                </div>
              ) : (
                <div className="article-panel">
                  <ExerciseBoard
                    segments={segments}
                    statuses={statuses}
                    answers={answers}
                    showCloze={showCloze}
                    wordListOpen={wordListOpen}
                    selectedWords={selectedWords}
                    blurWords={blurWords}
                    revealedIds={revealedIds}
                    activeIndex={activeIndex}
                    shadowingEnabled={shadowingEnabled}
                    shadowingSequence={shadowingSequence}
                    currentPlayingSpeed={currentPlayingSpeed}
                    onToggleWordList={toggleWordList}
                    onInputChange={handleChange}
                    onInputKeyDown={handleKeyDown}
                    onInputValidate={(segment, raw) => {
                      validateBlank(segment, raw);
                    }}
                    onInputFocus={(item) => {
                      activateAndPlay(item.index, {
                        repeat: Math.max(1, clampedFrCount),
                        triggerPreview: false,
                        triggerReveal: false,
                      });
                    }}
                    onChunkActivate={handleChunkActivate}
                    onKeyNavigate={onKeyNavigate}
                    imageMap={imageMap}
                    fetchImages={fetchImages}
                    onPlay={onPlay}
                    loadingWord={loadingWord}
                    onCopyArticle={copyArticle}
                    registerInputRef={(id, el) => {
                      if (el) {
                        inputRefs.current[id] = el;
                      } else {
                        delete inputRefs.current[id];
                      }
                    }}
                    registerChunkRef={registerChunkRef}
                    onPreview={(urls, idx) => {
                      setPreviewList(urls);
                      setPreviewIndex(idx);
                      setPreviewSrc(urls[idx]);
                    }}
                  />
                </div>
              )}
            </div>
          </div>
        </main>
      </div>

      <ConfigModal
        open={configOpen}
        onClose={() => setConfigOpen(false)}
        onSave={saveConfig}
        loading={configLoading}
        azureKey={azureKey}
        azureRegion={azureRegion}
        azureVoice={azureVoice}
        setAzureKey={setAzureKey}
        setAzureRegion={setAzureRegion}
        setAzureVoice={setAzureVoice}
      />
      <ShadowingConfigModal
        open={shadowingConfigOpen}
        onClose={() => setShadowingConfigOpen(false)}
        shadowingEnabled={shadowingEnabled}
        setShadowingEnabled={setShadowingEnabled}
        shadowingSequence={shadowingSequence}
        setShadowingSequence={setShadowingSequence}
      />

      <Modal
        open={!!previewSrc}
        footer={null}
        onCancel={() => {
          setPreviewSrc('');
          setPreviewList([]);
          setPreviewIndex(0);
        }}
        centered
        closable={false}
        maskClosable
        width="fit-content"
        styles={{
          body: { padding: 0 },
          content: { width: 'fit-content' },
        }}
        destroyOnHidden
      >
        <img
          src={previewList[previewIndex] || previewSrc}
          alt="预览"
          style={{ display: 'block', maxWidth: '80vw', maxHeight: '80vh', objectFit: 'contain' }}
        />
      </Modal>
    </>
  );
}
</file>

</files>
